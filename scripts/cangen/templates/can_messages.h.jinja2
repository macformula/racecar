/// @author Samuel Parent
/// @date {{ date }}

// WARNING: DO NOT MODIFY THIS CODE. THIS IS AN AUTOGENERATED FILE.

/// @todo support enums
/// @todo clang format
/// @todo make Id static inline
/// @todo make Clone work in a better way

// clang-format off

#pragma once

#include "shared/comms/can/can_msg.h"
#include "shared/comms/can/raw_can_msg.h"

namespace generated::can {

/* -------------------- RX MESSAGES -------------------- */

{% for msg in rx_msgs %}
{% set class_name = msg.name %}
class {{ class_name }} : public shared::can::CanRxMsg {
public:
    {% for sig in msg.signals %}
    {{ signal_types[msg.name][sig.name] }} {{ sig.name | camel_to_snake }} = 0;
    {% endfor %}

    // Measured in ms since program start
    uint32_t tick_timestamp = 0;

private:
    // Message properties
    static constexpr shared::can::CanId kCanId = {{ msg.frame_id | decimal_to_hex }};
    static constexpr uint8_t kDlc = {{ msg.length }};
    static constexpr bool kIsExtFrame = {{ msg.is_extended_frame | lower }};

    // Signal properties
    {% for sig in msg.signals %}
    {% set sig_var = sig.name | camel_to_snake %}
    {% set sig_var_type = signal_types[msg.name][sig.name] %}
    static constexpr {{ sig_var_type }} k{{ sig.name }}Scale = {{ sig.scale }};
    static constexpr {{ sig_var_type }} k{{ sig.name }}Offset = {{ sig.offset }};
    {% endfor %}

    shared::can::CanId Id() const override { return kCanId; } 

    void Clone(shared::can::CanRxMsg& rx_msg) const override {
        {{ class_name }}* p_rx_msg =  static_cast<{{ class_name }}*>(&rx_msg);

    {% for sig in msg.signals %}
    {% set sig_var = sig.name | camel_to_snake %}
        p_rx_msg->{{ sig_var }} = {{ sig_var }};
    {% endfor %}
        p_rx_msg->tick_timestamp = tick_timestamp;
    }

    void Unpack(const shared::can::RawCanMsg& raw_msg) override {
        if (raw_msg.header.id != kCanId) {
            return;
        }

        tick_timestamp = raw_msg.tick_timestamp;

        // temporary signal variables
    {% for sig in msg.signals %}
        {{ temp_signal_types[msg.name][sig.name] }} temp_{{ sig.name | camel_to_snake }} = 0;
    {% endfor %}

    {% for sig in msg.signals %}
        {% set masks, shifts = unpack_info[msg.name][sig.name] %}
        {% set temp_sig_var = "temp_" + sig.name | camel_to_snake %}
        {% set temp_sig_var_type = temp_signal_types[msg.name][sig.name] %}
        {% set sig_var = sig.name | camel_to_snake %}
        {% set sig_var_type = signal_types[msg.name][sig.name] %}
        {% set sig_var_scale = "k" + sig.name + "Scale" %}
        {% set sig_var_offset = "k" + sig.name + "Offset" %}
        {% for mask in masks %}
            {% set i = loop.index0 %}
            {% set shift = shifts[i] %}
            {% if mask != 0 %}
                {% if shift >= 0 %}
        {{ temp_sig_var }} |= unpack_left_shift<{{ temp_sig_var_type }}>(raw_msg.data[{{ i }}], {{ shift }}U, {{ mask | decimal_to_hex }}U);
                {% else %}
        {{ temp_sig_var }} |= unpack_right_shift<{{ temp_sig_var_type }}>(raw_msg.data[{{ i }}], {{ -shift }}U, {{ mask | decimal_to_hex }}U);
                {% endif %}
            {% endif %}
        {% endfor %}
        {{ sig_var }} = (static_cast<{{ sig_var_type }}>({{ temp_sig_var }}) * {{ sig_var_scale }}) + {{ sig_var_offset }};

    {% endfor %}
    }
};
{% endfor %}

/* -------------------- TX MESSAGES -------------------- */

{% for msg in tx_msgs %}
{% set class_name = msg.name %}
class {{ class_name }} : public shared::can::CanTxMsg {
public:
    {% for sig in msg.signals %}
    {{ signal_types[msg.name][sig.name] }} {{ sig.name | camel_to_snake }} = 0;
    {% endfor %}

private:
    // Message properties
    static constexpr shared::can::CanId kCanId = {{ msg.frame_id | decimal_to_hex }};
    static constexpr uint8_t kDlc = {{ msg.length }};
    static constexpr bool kIsExtFrame = {{ msg.is_extended_frame | lower }};

    // Signal properties
    {% for sig in msg.signals %}
    {% set sig_var = sig.name | camel_to_snake %}
    {% set sig_var_type = signal_types[msg.name][sig.name] %}
    static constexpr {{ sig_var_type }} k{{ sig.name }}Scale = {{ sig.scale }};
    static constexpr {{ sig_var_type }} k{{ sig.name }}Offset = {{ sig.offset }};
    {% endfor %}

    void Pack(shared::can::RawCanMsg& raw_msg) const override {
        // temporary raw msg
        shared::can::RawCanMsg temp_raw_msg;
        temp_raw_msg.header = {
            .id = kCanId,
            .data_len = kDlc,
            .is_extended_frame = kIsExtFrame,
        };

        // temporary signal variables
    {% for sig in msg.signals %}
        {% set sig_var = sig.name | camel_to_snake %}
        {% set sig_var_scale = "k" + sig.name + "Scale" %}
        {% set sig_var_offset = "k" + sig.name + "Offset" %}
        {% set temp_sig_var = "temp_" + (sig.name | camel_to_snake) %}
        {% set temp_sig_var_type = temp_signal_types[msg.name][sig.name] %}
        {{ temp_sig_var_type }} {{ temp_sig_var }} = static_cast<{{ temp_sig_var_type }}>(static_cast<double>({{ sig_var }} - {{ sig_var_offset }}) / static_cast<double>({{ sig_var_scale }}));
    {% endfor %}

    {% for sig in msg.signals %}
        {% set masks, shifts = pack_info[msg.name][sig.name] %}
        {% set temp_sig_var = "temp_" + sig.name | camel_to_snake %}
        {% set sig_var = sig.name | camel_to_snake %}
        {% set sig_var_type = signal_types[msg.name][sig.name] %}
        {% set sig_var_scale = "k" + sig.name + "Scale" %}
        {% set sig_var_offset = "k" + sig.name + "Offset" %}
        {% for mask in masks %}
            {% set i = loop.index0 %}
            {% set shift = shifts[i] %}
            {% if mask != 0 %}
                {% if shift >= 0 %}
        temp_raw_msg.data[{{ i }}] |= pack_right_shift({{ temp_sig_var }}, {{ shift }}U, {{ mask | decimal_to_hex }}U);
                {% else %}
        temp_raw_msg.data[{{ i }}] |= pack_left_shift({{ temp_sig_var }}, {{ -(shift) }}U, {{ mask | decimal_to_hex }}U);
                {% endif %}
            {% endif %}
        {% endfor %}
    {% endfor %}

        // Copy temp raw msg to raw msg
        raw_msg.Copy(temp_raw_msg);
    }
};
{% endfor %}

// clang-format on

}  // namespace generated::can