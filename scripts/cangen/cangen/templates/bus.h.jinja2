/// @author Samuel Parent, Blake Freer
/// @date November 2024

// WARNING: DO NOT MODIFY THIS CODE. THIS IS AN AUTOGENERATED FILE.

// clang-format off

#include <optional>

#include "shared/comms/can/bus.h"
#include "shared/comms/can/msg.h"
#include "shared/periph/can.h"
#include "{{bus_name | lower}}_messages.h"
#include "etl/mutex.h"

namespace generated::can {

{% set bus = bus_name+"Bus" %}
class {{ bus }} : public shared::can::Bus {
public:
    {{ bus }}(shared::periph::CanBase& can_base) : shared::can::Bus(can_base) {}

    {% for msg in rx_msgs %}
    {% set msg_title = "Rx"+msg.name %}

    // Get the latest message of type {{msg_title}}
    auto Get{{msg_title}}() -> std::optional<{{msg_title}}> {
        etl::lock_guard<etl::mutex> lock(msg_guard_);
        return {{ msg.name | camel_to_snake }}_msg_;
    }

    // Get the latest message of type {{msg_title}} and clear it
    auto Pop{{msg_title}}() -> std::optional<{{msg_title}}> {
        etl::lock_guard<etl::mutex> lock(msg_guard_);
        auto temp = {{ msg.name | camel_to_snake }}_msg_;
        {{ msg.name | camel_to_snake }}_msg_ = std::nullopt;
        return temp;
    }
    {% endfor %}

private:
    etl::mutex msg_guard_;

    void AddMessage(const shared::can::RawMessage& msg, uint32_t timestamp) override {
        etl::lock_guard<etl::mutex> lock(msg_guard_);
        switch(msg.id) {
            {% for msg in rx_msgs %}
            case Rx{{msg.name}}::id:
                {{ msg.name | camel_to_snake }}_msg_ = Rx{{msg.name}}(msg, timestamp);
                break;
            {% endfor %}
            default:
                break;  // ignore messages not intended for this node on this bus
        }
    }
    
    // All messages start empty and will be filled when the first instance arrives.
    {% for msg in rx_msgs %}
    std::optional<Rx{{ msg.name }}> {{msg.name | camel_to_snake}}_msg_ = std::nullopt;
    {% endfor %}

    friend class Base;
};

} // namespace generated::can

// clang-format on