/// @author Samuel Parent, Blake Freer
/// @date November 2024

// WARNING: DO NOT MODIFY THIS CODE. THIS IS AN AUTOGENERATED FILE.

/// @todo support enums
/// @todo clang format

// clang-format off

#pragma once

#include <cstdint>
#include "shared/comms/can/msg.hpp"
#include "etl/bitset.h"

namespace generated::can {

{% set bus = bus_name+"Bus" %}
class {{ bus }};

/* -------------------- ENUMS -------------------- */
{% for msg in all_msgs %}
    {% for sig in msg.signals %}
        {% if sig.choices %}  
enum class {{ sig.name }} {
            {% for value, name in sig.choices.items() | reverse %}
    {{ name }} = {{ value }},
            {% endfor %}
};
        {% endif %}
    {% endfor %}
{% endfor %}

/* -------------------- RX MESSAGES -------------------- */

{% for msg in rx_msgs %}
{% set class_name = "Rx"+msg.name %}
class {{ class_name }} {
public:
    {% for sig in msg.signals %}
    inline {{ signal_types[msg.name][sig.name] }} {{ sig.name }}() const { return {{ sig.name | camel_to_snake }}_; }
    {% endfor %}

private:
    {% for sig in msg.signals %}
    {{ signal_types[msg.name][sig.name] }} {{ sig.name | camel_to_snake }}_;
    {% endfor %}

    // Timestamp is platform dependent. See mcal/PLATFORM/periph/can
    uint32_t timestamp_;

    constexpr static uint32_t id = {{ msg.frame_id }};
    constexpr static uint8_t data_length = {{ msg.length }};

    {% for sig in msg.signals %}
    {% set sig_var = sig.name | camel_to_snake %}
    {% set sig_var_type = signal_types[msg.name][sig.name] %}
    static constexpr double k{{ sig.name }}Scale = {{ sig.scale }};
    static constexpr double k{{ sig.name }}Offset = {{ sig.offset }};
    {% endfor %}

    friend class {{ bus }};
public: // HACK for testing
    // Only {{ bus }} can construct this class which guarantees the data came from the CAN line.
    {{ class_name }}(shared::can::RawMessage raw_msg, uint32_t timestamp) {
        timestamp_ = timestamp;
        {% for sig in msg.signals %}
        {{ temp_signal_types[msg.name][sig.name] }} temp_{{ sig.name | camel_to_snake }} = 0;
        {% endfor %}

        {% for sig in msg.signals %}
        {% set masks, shifts = unpack_info[msg.name][sig.name] %}
        {% set temp_sig_var = "temp_" + sig.name | camel_to_snake %}
        {% set temp_sig_var_type = temp_signal_types[msg.name][sig.name] %}
        {% set sig_var = sig.name | camel_to_snake %}
        {% set sig_var_type = signal_types[msg.name][sig.name] %}
        {% set sig_var_scale = "k" + sig.name + "Scale" %}
        {% set sig_var_offset = "k" + sig.name + "Offset" %}
        {% for mask in masks %}
            {% set i = loop.index0 %}
            {% set shift = shifts[i] %}
            {% if mask != 0 %}
        etl::bitset<8> temp_bitset_{{ sig_var | camel_to_snake }}(raw_msg.data[{{ i }}]);
        etl::bitset<8> temp_mask_{{ sig_var | camel_to_snake }}({{ mask | decimal_to_hex }}U);
        temp_bitset_{{ sig_var | camel_to_snake }} &= temp_mask_{{ sig_var | camel_to_snake }};
                {% if shift >= 0 %}
        temp_bitset_{{ sig_var | camel_to_snake }} <<= {{ shift }}U;
                {% else %}
        temp_bitset_{{ sig_var | camel_to_snake }} >>= {{ -shift }}U;
                {% endif %}
        {{ temp_sig_var }} |= static_cast<{{ temp_sig_var_type }}>((int)(temp_bitset_{{ sig_var | camel_to_snake }}.to_ulong()));
            {% endif %}
            
        {% endfor %}
        {{ sig_var }}_ = static_cast<{{ sig_var_type }}>(static_cast<double>({{ temp_sig_var }}) * {{ sig_var_scale }} + {{ sig_var_offset }});

        {% endfor %}
    }
    {{ class_name }}() = delete;
};


{% endfor %}

/* -------------------- TX MESSAGES -------------------- */

{% for msg in tx_msgs %}
{% set class_name = "Tx"+msg.name %}
class {{ class_name }} {
public:
    {% for sig in msg.signals %}
    {{ signal_types[msg.name][sig.name] }} {{ sig.name | camel_to_snake }};
    {% endfor %}

    shared::can::RawMessage pack() const {
        uint8_t data[{{msg.length}}] = {};

        // @todo clamp data

        // temporary signal variables
        {% for sig in msg.signals %}
        {% set sig_var = sig.name | camel_to_snake %}
        {% set type = temp_signal_types[msg.name][sig.name] %}
        {{ type }} temp_{{ sig.name | camel_to_snake }} = static_cast<{{ type }}>(static_cast<double>({{ sig_var }} - k{{sig.name}}Offset ) / k{{sig.name}}Scale);
        {% endfor %}

        {% for sig in msg.signals %}
        {% set masks, shifts = pack_info[msg.name][sig.name] %}
        {% set sig_var = sig.name | camel_to_snake %}
        {% set sig_var_type = signal_types[msg.name][sig.name] %}
        {% for mask in masks %}
            {% set i = loop.index0 %}
            {% set shift = shifts[i] %}
            {% if mask != 0 %}
        etl::bitset<8> temp_bitset_{{ sig_var | camel_to_snake }}(temp_{{ sig_var }});
        etl::bitset<8> temp_mask_{{ sig_var | camel_to_snake }}({{ mask | decimal_to_hex }}U);
                {% if shift >= 0 %}
        temp_bitset_{{ sig_var | camel_to_snake }} >>= {{ shift }}U;
                {% else %}
        temp_bitset_{{ sig_var | camel_to_snake }} <<= {{ -shift }}U;
                {% endif %}
        temp_bitset_{{ sig_var | camel_to_snake }} &= temp_mask_{{ sig_var | camel_to_snake }};
        data[{{ i }}] |= static_cast<unsigned char>((int)(temp_bitset_{{ sig_var | camel_to_snake }}.to_ulong()));

            {% endif %}
        {% endfor %}
        {% endfor %}

        return shared::can::RawMessage(id, extended_frame, data_length, data);
    }

private:
    static constexpr uint32_t id = {{ msg.frame_id }};
    static constexpr uint8_t data_length = {{ msg.length }};
    constexpr static uint8_t extended_frame = {{ msg.is_extended_frame | lower }};

    // Signal properties
    {% for sig in msg.signals %}
    {% set sig_var = sig.name | camel_to_snake %}
    {% set sig_var_type = signal_types[msg.name][sig.name] %}
    static constexpr double k{{ sig.name }}Scale = {{ sig.scale }};
    static constexpr double k{{ sig.name }}Offset = {{ sig.offset }};
    {% endfor %}
};


{% endfor %}

}  // namespace generated::can

// clang-format on