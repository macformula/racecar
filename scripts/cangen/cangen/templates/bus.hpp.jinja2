/// @author Blake Freer
/// @date November 2024

// WARNING: DO NOT MODIFY THIS CODE. THIS IS AN AUTOGENERATED FILE.

// clang-format off

#include <optional>
#include <atomic>

#include "shared/comms/can/bus.hpp"
#include "shared/comms/can/msg.hpp"
#include "shared/periph/can.hpp"
#include "{{bus_name | lower}}_messages.hpp"

namespace generated::can {

{% set bus = bus_name+"Bus" %}
class {{ bus }} : public shared::can::Bus {
public:
    {{ bus }}(shared::periph::CanBase& can_base) : shared::can::Bus(can_base) {}

    {% for msg in rx_msgs %}
    {% set msg_title = "Rx"+msg.name %}
    // Get the latest message of type {{msg_title}}
    auto Get{{msg_title}}() -> std::optional<{{msg_title}}> {
        int read_pos = static_cast<int>({{msg.name | camel_to_snake}}_read_pos_);
        return {{ msg.name | camel_to_snake }}_buffer_[read_pos];
    }

    // Get the latest message of type {{msg_title}} and clear the optional
    auto Pop{{msg_title}}() -> std::optional<{{msg_title}}> {
        int read_pos = static_cast<int>({{msg.name | camel_to_snake}}_read_pos_);
        auto temp = {{ msg.name | camel_to_snake }}_buffer_[read_pos];
        {{ msg.name | camel_to_snake }}_buffer_[read_pos] = std::nullopt;
        return temp;
    }
    {% endfor %}

private:
    void AddMessage(const shared::can::RawMessage& msg, uint32_t timestamp) override {
        {% if rx_msgs %}
        bool write_pos_;
        switch(msg.id) {
            {% for msg in rx_msgs %}
            case Rx{{msg.name}}::id:
                write_pos_ = !{{msg.name | camel_to_snake}}_read_pos_;
                {{ msg.name | camel_to_snake }}_buffer_[static_cast<int>(write_pos_)] = Rx{{msg.name}}(msg, timestamp);
                {{ msg.name | camel_to_snake }}_read_pos_ = write_pos_;
                break;
            {% endfor %}
            default:
                break;  // ignore messages not intended for this node on this bus
        }
        {% else %}
        // The "{{node_name}}" CAN node does not receive any messages.
        // If this is a mistake, check that the node is:
        // 1. Set correctly in the project's config.yaml under the "{{bus_name}}" bus.
        // 2. Listed as a signal receiver in the DBC file.
        (void)msg;
        (void)timestamp;
        {% endif %}
    }
    
    {% if rx_msgs %}
    // All messages start empty and will be filled when the first instance arrives.
    // Use a buffer to avoid race conditions between AddMessage() and Get()/Pop()
    {% for msg in rx_msgs %}
    std::atomic_bool {{msg.name | camel_to_snake}}_read_pos_ = false;
    std::optional<Rx{{ msg.name }}> {{msg.name | camel_to_snake}}_buffer_[2] = {std::nullopt, std::nullopt};

    {% endfor %}
    {% endif %}
    friend class Base;
};

} // namespace generated::can

// clang-format on