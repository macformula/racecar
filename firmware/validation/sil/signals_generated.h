// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SIGNALS_SIGNALS_H_
#define FLATBUFFERS_GENERATED_SIGNALS_SIGNALS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace signals {

struct Digital;
struct DigitalBuilder;

struct Analog;
struct AnalogBuilder;

struct Request;
struct RequestBuilder;

struct ReadRequest;
struct ReadRequestBuilder;

struct SetRequest;
struct SetRequestBuilder;

struct RegisterRequest;
struct RegisterRequestBuilder;

struct Response;
struct ResponseBuilder;

struct ReadResponse;
struct ReadResponseBuilder;

struct SetResponse;
struct SetResponseBuilder;

struct RegisterResponse;
struct RegisterResponseBuilder;

enum SIGNAL_TYPE : int8_t {
  SIGNAL_TYPE_DIGITAL = 0,
  SIGNAL_TYPE_ANALOG = 1,
  SIGNAL_TYPE_MIN = SIGNAL_TYPE_DIGITAL,
  SIGNAL_TYPE_MAX = SIGNAL_TYPE_ANALOG
};

inline const SIGNAL_TYPE (&EnumValuesSIGNAL_TYPE())[2] {
  static const SIGNAL_TYPE values[] = {
    SIGNAL_TYPE_DIGITAL,
    SIGNAL_TYPE_ANALOG
  };
  return values;
}

inline const char * const *EnumNamesSIGNAL_TYPE() {
  static const char * const names[3] = {
    "DIGITAL",
    "ANALOG",
    nullptr
  };
  return names;
}

inline const char *EnumNameSIGNAL_TYPE(SIGNAL_TYPE e) {
  if (::flatbuffers::IsOutRange(e, SIGNAL_TYPE_DIGITAL, SIGNAL_TYPE_ANALOG)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSIGNAL_TYPE()[index];
}

enum SIGNAL_DIRECTION : int8_t {
  SIGNAL_DIRECTION_INPUT = 0,
  SIGNAL_DIRECTION_OUTPUT = 1,
  SIGNAL_DIRECTION_MIN = SIGNAL_DIRECTION_INPUT,
  SIGNAL_DIRECTION_MAX = SIGNAL_DIRECTION_OUTPUT
};

inline const SIGNAL_DIRECTION (&EnumValuesSIGNAL_DIRECTION())[2] {
  static const SIGNAL_DIRECTION values[] = {
    SIGNAL_DIRECTION_INPUT,
    SIGNAL_DIRECTION_OUTPUT
  };
  return values;
}

inline const char * const *EnumNamesSIGNAL_DIRECTION() {
  static const char * const names[3] = {
    "INPUT",
    "OUTPUT",
    nullptr
  };
  return names;
}

inline const char *EnumNameSIGNAL_DIRECTION(SIGNAL_DIRECTION e) {
  if (::flatbuffers::IsOutRange(e, SIGNAL_DIRECTION_INPUT, SIGNAL_DIRECTION_OUTPUT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSIGNAL_DIRECTION()[index];
}

enum SignalValue : uint8_t {
  SignalValue_NONE = 0,
  SignalValue_Digital = 1,
  SignalValue_Analog = 2,
  SignalValue_MIN = SignalValue_NONE,
  SignalValue_MAX = SignalValue_Analog
};

inline const SignalValue (&EnumValuesSignalValue())[3] {
  static const SignalValue values[] = {
    SignalValue_NONE,
    SignalValue_Digital,
    SignalValue_Analog
  };
  return values;
}

inline const char * const *EnumNamesSignalValue() {
  static const char * const names[4] = {
    "NONE",
    "Digital",
    "Analog",
    nullptr
  };
  return names;
}

inline const char *EnumNameSignalValue(SignalValue e) {
  if (::flatbuffers::IsOutRange(e, SignalValue_NONE, SignalValue_Analog)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSignalValue()[index];
}

template<typename T> struct SignalValueTraits {
  static const SignalValue enum_value = SignalValue_NONE;
};

template<> struct SignalValueTraits<signals::Digital> {
  static const SignalValue enum_value = SignalValue_Digital;
};

template<> struct SignalValueTraits<signals::Analog> {
  static const SignalValue enum_value = SignalValue_Analog;
};

bool VerifySignalValue(::flatbuffers::Verifier &verifier, const void *obj, SignalValue type);
bool VerifySignalValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum RequestType : uint8_t {
  RequestType_NONE = 0,
  RequestType_ReadRequest = 1,
  RequestType_SetRequest = 2,
  RequestType_RegisterRequest = 3,
  RequestType_MIN = RequestType_NONE,
  RequestType_MAX = RequestType_RegisterRequest
};

inline const RequestType (&EnumValuesRequestType())[4] {
  static const RequestType values[] = {
    RequestType_NONE,
    RequestType_ReadRequest,
    RequestType_SetRequest,
    RequestType_RegisterRequest
  };
  return values;
}

inline const char * const *EnumNamesRequestType() {
  static const char * const names[5] = {
    "NONE",
    "ReadRequest",
    "SetRequest",
    "RegisterRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestType(RequestType e) {
  if (::flatbuffers::IsOutRange(e, RequestType_NONE, RequestType_RegisterRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestType()[index];
}

template<typename T> struct RequestTypeTraits {
  static const RequestType enum_value = RequestType_NONE;
};

template<> struct RequestTypeTraits<signals::ReadRequest> {
  static const RequestType enum_value = RequestType_ReadRequest;
};

template<> struct RequestTypeTraits<signals::SetRequest> {
  static const RequestType enum_value = RequestType_SetRequest;
};

template<> struct RequestTypeTraits<signals::RegisterRequest> {
  static const RequestType enum_value = RequestType_RegisterRequest;
};

bool VerifyRequestType(::flatbuffers::Verifier &verifier, const void *obj, RequestType type);
bool VerifyRequestTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum ResponseType : uint8_t {
  ResponseType_NONE = 0,
  ResponseType_ReadResponse = 1,
  ResponseType_SetResponse = 2,
  ResponseType_MIN = ResponseType_NONE,
  ResponseType_MAX = ResponseType_SetResponse
};

inline const ResponseType (&EnumValuesResponseType())[3] {
  static const ResponseType values[] = {
    ResponseType_NONE,
    ResponseType_ReadResponse,
    ResponseType_SetResponse
  };
  return values;
}

inline const char * const *EnumNamesResponseType() {
  static const char * const names[4] = {
    "NONE",
    "ReadResponse",
    "SetResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameResponseType(ResponseType e) {
  if (::flatbuffers::IsOutRange(e, ResponseType_NONE, ResponseType_SetResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResponseType()[index];
}

template<typename T> struct ResponseTypeTraits {
  static const ResponseType enum_value = ResponseType_NONE;
};

template<> struct ResponseTypeTraits<signals::ReadResponse> {
  static const ResponseType enum_value = ResponseType_ReadResponse;
};

template<> struct ResponseTypeTraits<signals::SetResponse> {
  static const ResponseType enum_value = ResponseType_SetResponse;
};

bool VerifyResponseType(::flatbuffers::Verifier &verifier, const void *obj, ResponseType type);
bool VerifyResponseTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct Digital FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DigitalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct DigitalBuilder {
  typedef Digital Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(Digital::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit DigitalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Digital> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Digital>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Digital> CreateDigital(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  DigitalBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Analog FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnalogBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VOLTAGE = 4
  };
  double voltage() const {
    return GetField<double>(VT_VOLTAGE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VOLTAGE, 8) &&
           verifier.EndTable();
  }
};

struct AnalogBuilder {
  typedef Analog Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_voltage(double voltage) {
    fbb_.AddElement<double>(Analog::VT_VOLTAGE, voltage, 0.0);
  }
  explicit AnalogBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Analog> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Analog>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Analog> CreateAnalog(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double voltage = 0.0) {
  AnalogBuilder builder_(_fbb);
  builder_.add_voltage(voltage);
  return builder_.Finish();
}

struct Request FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUEST_TYPE = 4,
    VT_REQUEST = 6
  };
  signals::RequestType request_type() const {
    return static_cast<signals::RequestType>(GetField<uint8_t>(VT_REQUEST_TYPE, 0));
  }
  const void *request() const {
    return GetPointer<const void *>(VT_REQUEST);
  }
  template<typename T> const T *request_as() const;
  const signals::ReadRequest *request_as_ReadRequest() const {
    return request_type() == signals::RequestType_ReadRequest ? static_cast<const signals::ReadRequest *>(request()) : nullptr;
  }
  const signals::SetRequest *request_as_SetRequest() const {
    return request_type() == signals::RequestType_SetRequest ? static_cast<const signals::SetRequest *>(request()) : nullptr;
  }
  const signals::RegisterRequest *request_as_RegisterRequest() const {
    return request_type() == signals::RequestType_RegisterRequest ? static_cast<const signals::RegisterRequest *>(request()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_REQUEST_TYPE, 1) &&
           VerifyOffset(verifier, VT_REQUEST) &&
           VerifyRequestType(verifier, request(), request_type()) &&
           verifier.EndTable();
  }
};

template<> inline const signals::ReadRequest *Request::request_as<signals::ReadRequest>() const {
  return request_as_ReadRequest();
}

template<> inline const signals::SetRequest *Request::request_as<signals::SetRequest>() const {
  return request_as_SetRequest();
}

template<> inline const signals::RegisterRequest *Request::request_as<signals::RegisterRequest>() const {
  return request_as_RegisterRequest();
}

struct RequestBuilder {
  typedef Request Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_request_type(signals::RequestType request_type) {
    fbb_.AddElement<uint8_t>(Request::VT_REQUEST_TYPE, static_cast<uint8_t>(request_type), 0);
  }
  void add_request(::flatbuffers::Offset<void> request) {
    fbb_.AddOffset(Request::VT_REQUEST, request);
  }
  explicit RequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request> CreateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    signals::RequestType request_type = signals::RequestType_NONE,
    ::flatbuffers::Offset<void> request = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_request(request);
  builder_.add_request_type(request_type);
  return builder_.Finish();
}

struct ReadRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReadRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ECU_NAME = 4,
    VT_SIGNAL_NAME = 6,
    VT_SIGNAL_TYPE = 8,
    VT_SIGNAL_DIRECTION = 10
  };
  const ::flatbuffers::String *ecu_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ECU_NAME);
  }
  const ::flatbuffers::String *signal_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIGNAL_NAME);
  }
  signals::SIGNAL_TYPE signal_type() const {
    return static_cast<signals::SIGNAL_TYPE>(GetField<int8_t>(VT_SIGNAL_TYPE, 0));
  }
  signals::SIGNAL_DIRECTION signal_direction() const {
    return static_cast<signals::SIGNAL_DIRECTION>(GetField<int8_t>(VT_SIGNAL_DIRECTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ECU_NAME) &&
           verifier.VerifyString(ecu_name()) &&
           VerifyOffset(verifier, VT_SIGNAL_NAME) &&
           verifier.VerifyString(signal_name()) &&
           VerifyField<int8_t>(verifier, VT_SIGNAL_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_SIGNAL_DIRECTION, 1) &&
           verifier.EndTable();
  }
};

struct ReadRequestBuilder {
  typedef ReadRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ecu_name(::flatbuffers::Offset<::flatbuffers::String> ecu_name) {
    fbb_.AddOffset(ReadRequest::VT_ECU_NAME, ecu_name);
  }
  void add_signal_name(::flatbuffers::Offset<::flatbuffers::String> signal_name) {
    fbb_.AddOffset(ReadRequest::VT_SIGNAL_NAME, signal_name);
  }
  void add_signal_type(signals::SIGNAL_TYPE signal_type) {
    fbb_.AddElement<int8_t>(ReadRequest::VT_SIGNAL_TYPE, static_cast<int8_t>(signal_type), 0);
  }
  void add_signal_direction(signals::SIGNAL_DIRECTION signal_direction) {
    fbb_.AddElement<int8_t>(ReadRequest::VT_SIGNAL_DIRECTION, static_cast<int8_t>(signal_direction), 0);
  }
  explicit ReadRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReadRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReadRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReadRequest> CreateReadRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ecu_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> signal_name = 0,
    signals::SIGNAL_TYPE signal_type = signals::SIGNAL_TYPE_DIGITAL,
    signals::SIGNAL_DIRECTION signal_direction = signals::SIGNAL_DIRECTION_INPUT) {
  ReadRequestBuilder builder_(_fbb);
  builder_.add_signal_name(signal_name);
  builder_.add_ecu_name(ecu_name);
  builder_.add_signal_direction(signal_direction);
  builder_.add_signal_type(signal_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReadRequest> CreateReadRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ecu_name = nullptr,
    const char *signal_name = nullptr,
    signals::SIGNAL_TYPE signal_type = signals::SIGNAL_TYPE_DIGITAL,
    signals::SIGNAL_DIRECTION signal_direction = signals::SIGNAL_DIRECTION_INPUT) {
  auto ecu_name__ = ecu_name ? _fbb.CreateString(ecu_name) : 0;
  auto signal_name__ = signal_name ? _fbb.CreateString(signal_name) : 0;
  return signals::CreateReadRequest(
      _fbb,
      ecu_name__,
      signal_name__,
      signal_type,
      signal_direction);
}

struct SetRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ECU_NAME = 4,
    VT_SIGNAL_NAME = 6,
    VT_SIGNAL_TYPE = 8,
    VT_SIGNAL_VALUE_TYPE = 10,
    VT_SIGNAL_VALUE = 12,
    VT_SIGNAL_DIRECTION = 14
  };
  const ::flatbuffers::String *ecu_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ECU_NAME);
  }
  const ::flatbuffers::String *signal_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIGNAL_NAME);
  }
  signals::SIGNAL_TYPE signal_type() const {
    return static_cast<signals::SIGNAL_TYPE>(GetField<int8_t>(VT_SIGNAL_TYPE, 0));
  }
  signals::SignalValue signal_value_type() const {
    return static_cast<signals::SignalValue>(GetField<uint8_t>(VT_SIGNAL_VALUE_TYPE, 0));
  }
  const void *signal_value() const {
    return GetPointer<const void *>(VT_SIGNAL_VALUE);
  }
  template<typename T> const T *signal_value_as() const;
  const signals::Digital *signal_value_as_Digital() const {
    return signal_value_type() == signals::SignalValue_Digital ? static_cast<const signals::Digital *>(signal_value()) : nullptr;
  }
  const signals::Analog *signal_value_as_Analog() const {
    return signal_value_type() == signals::SignalValue_Analog ? static_cast<const signals::Analog *>(signal_value()) : nullptr;
  }
  signals::SIGNAL_DIRECTION signal_direction() const {
    return static_cast<signals::SIGNAL_DIRECTION>(GetField<int8_t>(VT_SIGNAL_DIRECTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ECU_NAME) &&
           verifier.VerifyString(ecu_name()) &&
           VerifyOffset(verifier, VT_SIGNAL_NAME) &&
           verifier.VerifyString(signal_name()) &&
           VerifyField<int8_t>(verifier, VT_SIGNAL_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_SIGNAL_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_SIGNAL_VALUE) &&
           VerifySignalValue(verifier, signal_value(), signal_value_type()) &&
           VerifyField<int8_t>(verifier, VT_SIGNAL_DIRECTION, 1) &&
           verifier.EndTable();
  }
};

template<> inline const signals::Digital *SetRequest::signal_value_as<signals::Digital>() const {
  return signal_value_as_Digital();
}

template<> inline const signals::Analog *SetRequest::signal_value_as<signals::Analog>() const {
  return signal_value_as_Analog();
}

struct SetRequestBuilder {
  typedef SetRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ecu_name(::flatbuffers::Offset<::flatbuffers::String> ecu_name) {
    fbb_.AddOffset(SetRequest::VT_ECU_NAME, ecu_name);
  }
  void add_signal_name(::flatbuffers::Offset<::flatbuffers::String> signal_name) {
    fbb_.AddOffset(SetRequest::VT_SIGNAL_NAME, signal_name);
  }
  void add_signal_type(signals::SIGNAL_TYPE signal_type) {
    fbb_.AddElement<int8_t>(SetRequest::VT_SIGNAL_TYPE, static_cast<int8_t>(signal_type), 0);
  }
  void add_signal_value_type(signals::SignalValue signal_value_type) {
    fbb_.AddElement<uint8_t>(SetRequest::VT_SIGNAL_VALUE_TYPE, static_cast<uint8_t>(signal_value_type), 0);
  }
  void add_signal_value(::flatbuffers::Offset<void> signal_value) {
    fbb_.AddOffset(SetRequest::VT_SIGNAL_VALUE, signal_value);
  }
  void add_signal_direction(signals::SIGNAL_DIRECTION signal_direction) {
    fbb_.AddElement<int8_t>(SetRequest::VT_SIGNAL_DIRECTION, static_cast<int8_t>(signal_direction), 0);
  }
  explicit SetRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetRequest> CreateSetRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ecu_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> signal_name = 0,
    signals::SIGNAL_TYPE signal_type = signals::SIGNAL_TYPE_DIGITAL,
    signals::SignalValue signal_value_type = signals::SignalValue_NONE,
    ::flatbuffers::Offset<void> signal_value = 0,
    signals::SIGNAL_DIRECTION signal_direction = signals::SIGNAL_DIRECTION_INPUT) {
  SetRequestBuilder builder_(_fbb);
  builder_.add_signal_value(signal_value);
  builder_.add_signal_name(signal_name);
  builder_.add_ecu_name(ecu_name);
  builder_.add_signal_direction(signal_direction);
  builder_.add_signal_value_type(signal_value_type);
  builder_.add_signal_type(signal_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SetRequest> CreateSetRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ecu_name = nullptr,
    const char *signal_name = nullptr,
    signals::SIGNAL_TYPE signal_type = signals::SIGNAL_TYPE_DIGITAL,
    signals::SignalValue signal_value_type = signals::SignalValue_NONE,
    ::flatbuffers::Offset<void> signal_value = 0,
    signals::SIGNAL_DIRECTION signal_direction = signals::SIGNAL_DIRECTION_INPUT) {
  auto ecu_name__ = ecu_name ? _fbb.CreateString(ecu_name) : 0;
  auto signal_name__ = signal_name ? _fbb.CreateString(signal_name) : 0;
  return signals::CreateSetRequest(
      _fbb,
      ecu_name__,
      signal_name__,
      signal_type,
      signal_value_type,
      signal_value,
      signal_direction);
}

struct RegisterRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RegisterRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ECU_NAME = 4,
    VT_SIGNAL_NAME = 6,
    VT_SIGNAL_TYPE = 8,
    VT_SIGNAL_DIRECTION = 10
  };
  const ::flatbuffers::String *ecu_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ECU_NAME);
  }
  const ::flatbuffers::String *signal_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIGNAL_NAME);
  }
  signals::SIGNAL_TYPE signal_type() const {
    return static_cast<signals::SIGNAL_TYPE>(GetField<int8_t>(VT_SIGNAL_TYPE, 0));
  }
  signals::SIGNAL_DIRECTION signal_direction() const {
    return static_cast<signals::SIGNAL_DIRECTION>(GetField<int8_t>(VT_SIGNAL_DIRECTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ECU_NAME) &&
           verifier.VerifyString(ecu_name()) &&
           VerifyOffset(verifier, VT_SIGNAL_NAME) &&
           verifier.VerifyString(signal_name()) &&
           VerifyField<int8_t>(verifier, VT_SIGNAL_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_SIGNAL_DIRECTION, 1) &&
           verifier.EndTable();
  }
};

struct RegisterRequestBuilder {
  typedef RegisterRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ecu_name(::flatbuffers::Offset<::flatbuffers::String> ecu_name) {
    fbb_.AddOffset(RegisterRequest::VT_ECU_NAME, ecu_name);
  }
  void add_signal_name(::flatbuffers::Offset<::flatbuffers::String> signal_name) {
    fbb_.AddOffset(RegisterRequest::VT_SIGNAL_NAME, signal_name);
  }
  void add_signal_type(signals::SIGNAL_TYPE signal_type) {
    fbb_.AddElement<int8_t>(RegisterRequest::VT_SIGNAL_TYPE, static_cast<int8_t>(signal_type), 0);
  }
  void add_signal_direction(signals::SIGNAL_DIRECTION signal_direction) {
    fbb_.AddElement<int8_t>(RegisterRequest::VT_SIGNAL_DIRECTION, static_cast<int8_t>(signal_direction), 0);
  }
  explicit RegisterRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RegisterRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RegisterRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RegisterRequest> CreateRegisterRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ecu_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> signal_name = 0,
    signals::SIGNAL_TYPE signal_type = signals::SIGNAL_TYPE_DIGITAL,
    signals::SIGNAL_DIRECTION signal_direction = signals::SIGNAL_DIRECTION_INPUT) {
  RegisterRequestBuilder builder_(_fbb);
  builder_.add_signal_name(signal_name);
  builder_.add_ecu_name(ecu_name);
  builder_.add_signal_direction(signal_direction);
  builder_.add_signal_type(signal_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RegisterRequest> CreateRegisterRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ecu_name = nullptr,
    const char *signal_name = nullptr,
    signals::SIGNAL_TYPE signal_type = signals::SIGNAL_TYPE_DIGITAL,
    signals::SIGNAL_DIRECTION signal_direction = signals::SIGNAL_DIRECTION_INPUT) {
  auto ecu_name__ = ecu_name ? _fbb.CreateString(ecu_name) : 0;
  auto signal_name__ = signal_name ? _fbb.CreateString(signal_name) : 0;
  return signals::CreateRegisterRequest(
      _fbb,
      ecu_name__,
      signal_name__,
      signal_type,
      signal_direction);
}

struct Response FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESPONSE_TYPE = 4,
    VT_RESPONSE = 6
  };
  signals::ResponseType response_type() const {
    return static_cast<signals::ResponseType>(GetField<uint8_t>(VT_RESPONSE_TYPE, 0));
  }
  const void *response() const {
    return GetPointer<const void *>(VT_RESPONSE);
  }
  template<typename T> const T *response_as() const;
  const signals::ReadResponse *response_as_ReadResponse() const {
    return response_type() == signals::ResponseType_ReadResponse ? static_cast<const signals::ReadResponse *>(response()) : nullptr;
  }
  const signals::SetResponse *response_as_SetResponse() const {
    return response_type() == signals::ResponseType_SetResponse ? static_cast<const signals::SetResponse *>(response()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESPONSE_TYPE, 1) &&
           VerifyOffset(verifier, VT_RESPONSE) &&
           VerifyResponseType(verifier, response(), response_type()) &&
           verifier.EndTable();
  }
};

template<> inline const signals::ReadResponse *Response::response_as<signals::ReadResponse>() const {
  return response_as_ReadResponse();
}

template<> inline const signals::SetResponse *Response::response_as<signals::SetResponse>() const {
  return response_as_SetResponse();
}

struct ResponseBuilder {
  typedef Response Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_response_type(signals::ResponseType response_type) {
    fbb_.AddElement<uint8_t>(Response::VT_RESPONSE_TYPE, static_cast<uint8_t>(response_type), 0);
  }
  void add_response(::flatbuffers::Offset<void> response) {
    fbb_.AddOffset(Response::VT_RESPONSE, response);
  }
  explicit ResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response> CreateResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    signals::ResponseType response_type = signals::ResponseType_NONE,
    ::flatbuffers::Offset<void> response = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_response(response);
  builder_.add_response_type(response_type);
  return builder_.Finish();
}

struct ReadResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReadResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIGNAL_VALUE_TYPE = 4,
    VT_SIGNAL_VALUE = 6,
    VT_OK = 8,
    VT_ERROR = 10
  };
  signals::SignalValue signal_value_type() const {
    return static_cast<signals::SignalValue>(GetField<uint8_t>(VT_SIGNAL_VALUE_TYPE, 0));
  }
  const void *signal_value() const {
    return GetPointer<const void *>(VT_SIGNAL_VALUE);
  }
  template<typename T> const T *signal_value_as() const;
  const signals::Digital *signal_value_as_Digital() const {
    return signal_value_type() == signals::SignalValue_Digital ? static_cast<const signals::Digital *>(signal_value()) : nullptr;
  }
  const signals::Analog *signal_value_as_Analog() const {
    return signal_value_type() == signals::SignalValue_Analog ? static_cast<const signals::Analog *>(signal_value()) : nullptr;
  }
  bool ok() const {
    return GetField<uint8_t>(VT_OK, 1) != 0;
  }
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SIGNAL_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_SIGNAL_VALUE) &&
           VerifySignalValue(verifier, signal_value(), signal_value_type()) &&
           VerifyField<uint8_t>(verifier, VT_OK, 1) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
};

template<> inline const signals::Digital *ReadResponse::signal_value_as<signals::Digital>() const {
  return signal_value_as_Digital();
}

template<> inline const signals::Analog *ReadResponse::signal_value_as<signals::Analog>() const {
  return signal_value_as_Analog();
}

struct ReadResponseBuilder {
  typedef ReadResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_signal_value_type(signals::SignalValue signal_value_type) {
    fbb_.AddElement<uint8_t>(ReadResponse::VT_SIGNAL_VALUE_TYPE, static_cast<uint8_t>(signal_value_type), 0);
  }
  void add_signal_value(::flatbuffers::Offset<void> signal_value) {
    fbb_.AddOffset(ReadResponse::VT_SIGNAL_VALUE, signal_value);
  }
  void add_ok(bool ok) {
    fbb_.AddElement<uint8_t>(ReadResponse::VT_OK, static_cast<uint8_t>(ok), 1);
  }
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(ReadResponse::VT_ERROR, error);
  }
  explicit ReadResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReadResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReadResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReadResponse> CreateReadResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    signals::SignalValue signal_value_type = signals::SignalValue_NONE,
    ::flatbuffers::Offset<void> signal_value = 0,
    bool ok = true,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0) {
  ReadResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_signal_value(signal_value);
  builder_.add_ok(ok);
  builder_.add_signal_value_type(signal_value_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReadResponse> CreateReadResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    signals::SignalValue signal_value_type = signals::SignalValue_NONE,
    ::flatbuffers::Offset<void> signal_value = 0,
    bool ok = true,
    const char *error = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return signals::CreateReadResponse(
      _fbb,
      signal_value_type,
      signal_value,
      ok,
      error__);
}

struct SetResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OK = 4,
    VT_ERROR = 6
  };
  bool ok() const {
    return GetField<uint8_t>(VT_OK, 1) != 0;
  }
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OK, 1) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
};

struct SetResponseBuilder {
  typedef SetResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ok(bool ok) {
    fbb_.AddElement<uint8_t>(SetResponse::VT_OK, static_cast<uint8_t>(ok), 1);
  }
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(SetResponse::VT_ERROR, error);
  }
  explicit SetResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetResponse> CreateSetResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool ok = true,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0) {
  SetResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_ok(ok);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SetResponse> CreateSetResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool ok = true,
    const char *error = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return signals::CreateSetResponse(
      _fbb,
      ok,
      error__);
}

struct RegisterResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RegisterResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OK = 4,
    VT_ERROR = 6
  };
  bool ok() const {
    return GetField<uint8_t>(VT_OK, 1) != 0;
  }
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OK, 1) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
};

struct RegisterResponseBuilder {
  typedef RegisterResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ok(bool ok) {
    fbb_.AddElement<uint8_t>(RegisterResponse::VT_OK, static_cast<uint8_t>(ok), 1);
  }
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(RegisterResponse::VT_ERROR, error);
  }
  explicit RegisterResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RegisterResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RegisterResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RegisterResponse> CreateRegisterResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool ok = true,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0) {
  RegisterResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_ok(ok);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RegisterResponse> CreateRegisterResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool ok = true,
    const char *error = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return signals::CreateRegisterResponse(
      _fbb,
      ok,
      error__);
}

inline bool VerifySignalValue(::flatbuffers::Verifier &verifier, const void *obj, SignalValue type) {
  switch (type) {
    case SignalValue_NONE: {
      return true;
    }
    case SignalValue_Digital: {
      auto ptr = reinterpret_cast<const signals::Digital *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SignalValue_Analog: {
      auto ptr = reinterpret_cast<const signals::Analog *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifySignalValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySignalValue(
        verifier,  values->Get(i), types->GetEnum<SignalValue>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyRequestType(::flatbuffers::Verifier &verifier, const void *obj, RequestType type) {
  switch (type) {
    case RequestType_NONE: {
      return true;
    }
    case RequestType_ReadRequest: {
      auto ptr = reinterpret_cast<const signals::ReadRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestType_SetRequest: {
      auto ptr = reinterpret_cast<const signals::SetRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestType_RegisterRequest: {
      auto ptr = reinterpret_cast<const signals::RegisterRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRequestTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRequestType(
        verifier,  values->Get(i), types->GetEnum<RequestType>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyResponseType(::flatbuffers::Verifier &verifier, const void *obj, ResponseType type) {
  switch (type) {
    case ResponseType_NONE: {
      return true;
    }
    case ResponseType_ReadResponse: {
      auto ptr = reinterpret_cast<const signals::ReadResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseType_SetResponse: {
      auto ptr = reinterpret_cast<const signals::SetResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyResponseTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResponseType(
        verifier,  values->Get(i), types->GetEnum<ResponseType>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace signals

#endif  // FLATBUFFERS_GENERATED_SIGNALS_SIGNALS_H_
