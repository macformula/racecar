/// @author Samuel Parent
/// @date 2024-04-13

// WARNING: DO NOT MODIFY THIS CODE. THIS IS AN AUTOGENERATED FILE.

/// @todo support enums
/// @todo clang format
/// @todo make Id static inline
/// @todo make Clone work in a better way

// clang-format off

#pragma once

#include "shared/comms/can/can_msg.h"
#include "shared/comms/can/raw_can_msg.h"

namespace generated::can {

/* -------------------- RX MESSAGES -------------------- */

class VehicleInfo : public shared::can::CanRxMsg {
public:
    float requested_speed = 0;
    float wheel_speed = 0;

private:
    // Message properties
    static constexpr shared::can::CanId kCanId = 0x245;
    static constexpr uint8_t kDlc = 8;
    static constexpr bool kIsExtFrame = false;

    // Signal properties
    static constexpr float kRequestedSpeedScale = 0.00390625;
    static constexpr float kRequestedSpeedOffset = 0;
    static constexpr float kWheelSpeedScale = 0.00390625;
    static constexpr float kWheelSpeedOffset = 0;

    shared::can::CanId Id() const override { return kCanId; } 

    void Clone(shared::can::CanRxMsg& rx_msg) const override {
        VehicleInfo* p_rx_msg =  static_cast<VehicleInfo*>(&rx_msg);

        p_rx_msg->requested_speed = requested_speed;
        p_rx_msg->wheel_speed = wheel_speed;
    }

    void Unpack(const shared::can::RawCanMsg& raw_msg) override {
        if (raw_msg.header.id != kCanId) {
            return;
        }

        // temporary signal variables
        uint32_t temp_requested_speed = 0;
        uint32_t temp_wheel_speed = 0;

        temp_requested_speed |= unpack_left_shift<uint32_t>(raw_msg.data[0], 20U, 0xfU);
        temp_requested_speed |= unpack_left_shift<uint32_t>(raw_msg.data[1], 12U, 0xffU);
        temp_requested_speed |= unpack_left_shift<uint32_t>(raw_msg.data[2], 4U, 0xffU);
        temp_requested_speed |= unpack_right_shift<uint32_t>(raw_msg.data[3], 4U, 0xf0U);
        requested_speed = (static_cast<float>(temp_requested_speed) * kRequestedSpeedScale) + kRequestedSpeedOffset;

        temp_wheel_speed |= unpack_left_shift<uint32_t>(raw_msg.data[3], 29U, 0x7U);
        temp_wheel_speed |= unpack_left_shift<uint32_t>(raw_msg.data[4], 21U, 0xffU);
        temp_wheel_speed |= unpack_left_shift<uint32_t>(raw_msg.data[5], 13U, 0xffU);
        temp_wheel_speed |= unpack_left_shift<uint32_t>(raw_msg.data[6], 5U, 0xffU);
        temp_wheel_speed |= unpack_right_shift<uint32_t>(raw_msg.data[7], 3U, 0xf8U);
        wheel_speed = (static_cast<float>(temp_wheel_speed) * kWheelSpeedScale) + kWheelSpeedOffset;

    }
};

/* -------------------- TX MESSAGES -------------------- */

class TempSensors : public shared::can::CanTxMsg {
public:
    float sensor6 = 0;
    float sensor5 = 0;
    float sensor4 = 0;
    float sensor3 = 0;
    float sensor2 = 0;
    float sensor1 = 0;

private:
    // Message properties
    static constexpr shared::can::CanId kCanId = 0x3ac;
    static constexpr uint8_t kDlc = 8;
    static constexpr bool kIsExtFrame = false;

    // Signal properties
    static constexpr float kSensor6Scale = 0.2;
    static constexpr float kSensor6Offset = 0;
    static constexpr float kSensor5Scale = 0.2;
    static constexpr float kSensor5Offset = 0;
    static constexpr float kSensor4Scale = 0.2;
    static constexpr float kSensor4Offset = 0;
    static constexpr float kSensor3Scale = 0.2;
    static constexpr float kSensor3Offset = 0;
    static constexpr float kSensor2Scale = 0.2;
    static constexpr float kSensor2Offset = 0;
    static constexpr float kSensor1Scale = 0.2;
    static constexpr float kSensor1Offset = 0;

    void Pack(shared::can::RawCanMsg& raw_msg) const override {
        // temporary raw msg
        shared::can::RawCanMsg temp_raw_msg;
        temp_raw_msg.header = {
            .id = kCanId,
            .data_len = kDlc,
            .is_extended_frame = kIsExtFrame,
        };

        // temporary signal variables
        int16_t temp_sensor6 = static_cast<int16_t>(static_cast<double>(sensor6 - kSensor6Offset) / static_cast<double>(kSensor6Scale));
        int16_t temp_sensor5 = static_cast<int16_t>(static_cast<double>(sensor5 - kSensor5Offset) / static_cast<double>(kSensor5Scale));
        int16_t temp_sensor4 = static_cast<int16_t>(static_cast<double>(sensor4 - kSensor4Offset) / static_cast<double>(kSensor4Scale));
        int16_t temp_sensor3 = static_cast<int16_t>(static_cast<double>(sensor3 - kSensor3Offset) / static_cast<double>(kSensor3Scale));
        int16_t temp_sensor2 = static_cast<int16_t>(static_cast<double>(sensor2 - kSensor2Offset) / static_cast<double>(kSensor2Scale));
        int16_t temp_sensor1 = static_cast<int16_t>(static_cast<double>(sensor1 - kSensor1Offset) / static_cast<double>(kSensor1Scale));

        temp_raw_msg.data[0] |= pack_left_shift(temp_sensor6, 4U, 0xf0U);
        temp_raw_msg.data[1] |= pack_right_shift(temp_sensor6, 4U, 0x3fU);
        temp_raw_msg.data[1] |= pack_left_shift(temp_sensor5, 6U, 0xc0U);
        temp_raw_msg.data[2] |= pack_right_shift(temp_sensor5, 2U, 0xffU);
        temp_raw_msg.data[3] |= pack_right_shift(temp_sensor4, 0U, 0xffU);
        temp_raw_msg.data[4] |= pack_right_shift(temp_sensor4, 8U, 0x3U);
        temp_raw_msg.data[4] |= pack_left_shift(temp_sensor3, 2U, 0xfcU);
        temp_raw_msg.data[5] |= pack_right_shift(temp_sensor3, 6U, 0xfU);
        temp_raw_msg.data[5] |= pack_left_shift(temp_sensor2, 4U, 0xf0U);
        temp_raw_msg.data[6] |= pack_right_shift(temp_sensor2, 4U, 0x3fU);
        temp_raw_msg.data[6] |= pack_left_shift(temp_sensor1, 6U, 0xc0U);
        temp_raw_msg.data[7] |= pack_right_shift(temp_sensor1, 2U, 0xffU);

        // Copy temp raw msg to raw msg
        raw_msg.Copy(temp_raw_msg);
    }
};

// clang-format on

}  // namespace generated::can