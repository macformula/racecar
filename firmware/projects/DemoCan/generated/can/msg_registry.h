/// @author Samuel Parent
/// @date 2024-04-13

// WARNING: DO NOT MODIFY THIS CODE. THIS IS AN AUTOGENERATED FILE.

#pragma once

#include "can_messages.h"
#include "shared/comms/can/can_msg.h"
#include "shared/comms/can/msg_registry.h"
#include "shared/comms/can/raw_can_msg.h"
#include "etl/unordered_map.h"

namespace generated::can {

class VehMsgRegistry : public shared::can::MsgRegistry {
public:
    bool SetMessage(const shared::can::RawCanMsg& raw_msg) {
        bool msg_found = false;

        if (rx_msg_map_.count(raw_msg.header.id) > 0) {
            msg_found = true;

            Unpack(rx_msg_map_[raw_msg.header.id], raw_msg);
        }

        return msg_found;
    }

    bool GetMessage(shared::can::CanRxMsg& rx_msg) {
        bool msg_found = false;

        shared::can::CanId mid = MsgId(&rx_msg);

        if (rx_msg_map_.count(mid) > 0) {
            msg_found = true;

            Clone(rx_msg_map_[mid], rx_msg);
        }

        return msg_found;
    }

private:
    static constexpr size_t kNumRxMsgs = 1;

    // Message IDs
    static constexpr shared::can::CanId kVehicleInfoCanId = 0x245;

    // Can Rx Messages
    VehicleInfo vehicle_info_;

    etl::unordered_map<shared::can::CanId, shared::can::CanRxMsg*, kNumRxMsgs>
    rx_msg_map_ = {
        { kVehicleInfoCanId, &vehicle_info_ },
    };
};

}  // namespace generated::can