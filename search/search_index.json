{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The racecar/ repository","text":""},{"location":"#the-racecar-repository","title":"The racecar/ repository","text":""},{"location":"#firmware","title":"Firmware","text":""},{"location":"#tutorials","title":"Tutorials","text":""},{"location":"#using-this-documentation","title":"Using this documentation","text":"<p> Follow links from highlighted text like this.</p> <p> Hover over abbreviations to show the definition. Also see the Glossary.</p> <p>Mac FSAE worked on EV5 during the 2023-2024 school year.</p> <p> Copy code by clicking the icon at the top right of a code block.</p> copyme.cc<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Go Marauders!\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p> Find content throughout the site with the search bar.</p> <p>Press F, S, or / to quickly access the search.</p>"},{"location":"glossary/","title":"Glossary","text":""},{"location":"glossary/#glossary","title":"Glossary","text":""},{"location":"glossary/#adc","title":"ADC","text":"<p>Analog-to-Digital Converter. A microcontroller peripheral which measures analog voltages.</p>"},{"location":"glossary/#bms","title":"BMS","text":"<p>Battery Management System. A vehicle device responsible for consistently and safely drawing power from the accumulator / battery.</p>"},{"location":"glossary/#bms_1","title":"BMS","text":"<p>Battery Management System.</p>"},{"location":"glossary/#can","title":"CAN","text":"<p>Controller Area Network. A vehicle bus protocol standardizing communication between ECUs.</p>"},{"location":"glossary/#cli","title":"CLI","text":"<p>Command line interface, also known as the terminal or command prompt.</p>"},{"location":"glossary/#dbc","title":"DBC","text":"<p>DataBase CAN. A file format for describing CAN messages.</p>"},{"location":"glossary/#ecu","title":"ECU","text":"<p>Electronic Control Unit. A microcontroller in a vehicle.</p>"},{"location":"glossary/#ev5","title":"EV5","text":"<p>Mac FSAE's 5th Electric Vehicle. Created during the 2023-2024 season.</p>"},{"location":"glossary/#ev6","title":"EV6","text":"<p>Mac FSAE's 6th Electric Vehicle. Created during the 2024-2025 season.</p>"},{"location":"glossary/#fsae","title":"FSAE","text":"<p>Formula SAE. A student design competition to build a Formula-style racecar.</p>"},{"location":"glossary/#gpio","title":"GPIO","text":"<p>General-purpose Input Output. A pin on an integrated circuit that can function as a digital input or output.</p>"},{"location":"glossary/#grpc","title":"gRPC","text":"<p>gRPC Remote Procedure Calls. A open source framework for remote procedure calls.</p>"},{"location":"glossary/#hal","title":"HAL","text":"<p>Hardware Abstraction Layer. A programming layer that abstracts away the internal workings of a microcontroller.</p>"},{"location":"glossary/#hil","title":"HIL","text":"<p>Hardware-In-the-Loop. A test setup where an actual ECU and its board are connected to a hardware simulator.</p>"},{"location":"glossary/#hv","title":"HV","text":"<p>High Voltage. The vehicle circuit which powers our motors. Contrast with LV.</p>"},{"location":"glossary/#jtag","title":"JTAG","text":"<p>Joint Test Action Group. Usually refers to a standardized connector for programming and debugging microcontrollers.</p>"},{"location":"glossary/#lv","title":"LV","text":"<p>Low Voltage. The vehicle circuit that powers all non-motor electronics. Contrast with HV.</p>"},{"location":"glossary/#mcal","title":"MCAL","text":"<p>MicroController Abstraction Layer.</p>"},{"location":"glossary/#mcu","title":"MCU","text":"<p>MicroController Unit</p>"},{"location":"glossary/#mpu","title":"MPU","text":"<p>MicroProcessor Unit</p>"},{"location":"glossary/#pcb","title":"PCB","text":"<p>Printed Circuit Board.</p>"},{"location":"glossary/#pwm","title":"PWM","text":"<p>Pulse Width Modulation. A method for generating an analog voltage by rapidly pulsing digital signals while varying the duty cycle.</p>"},{"location":"glossary/#sae","title":"SAE","text":"<p>A professional association involved in the automotive, transport, and aerospace industries. Formerly the Society of Automotive Engineers.</p>"},{"location":"glossary/#sil","title":"SIL","text":"<p>Software-In-the-Loop. A test setup where the ECU and external conditions are simulated.</p>"},{"location":"glossary/#soc","title":"SoC","text":"<p>State of Charge. The amount of charge left in the accumulator (100% = full charge).</p>"},{"location":"glossary/#ssh","title":"SSH","text":"<p>Secure Shell.</p>"},{"location":"glossary/#tms","title":"TMS","text":"<p>Thermal Management System. Responsible for measuring and reporting the vehicle's battery temperature.</p>"},{"location":"glossary/#tssi","title":"TSSI","text":"<p>Tractive System Status Indicator. A light on the vehicle which indicates when the vehicle has power or errors. Required by FSAE rule EV.5.11.5.</p> <p>This file was autogenerated by <code>docs/includes/gen_glossary.py</code>.</p>"},{"location":"firmware/","title":"Firmware","text":""},{"location":"firmware/#firmware","title":"Firmware","text":""},{"location":"firmware/#development-setup","title":"Development Setup","text":""},{"location":"firmware/#using-platformio","title":"Using PlatformIO","text":""},{"location":"firmware/architecture/","title":"Architecture","text":""},{"location":"firmware/architecture/#architecture","title":"Architecture","text":"<p>Code in our monorepo is organized based on two binary traits: Project (ECU) Specificity and Platform Specificity.</p> <p> </p> <p>Most of the architecture is described by the interplay in project-specific sections, i.e. the left column of this diagram.</p> <p>Our project-specific firmware is separated in 2 layers:</p> <p>The application (app) layer describes the what the project does at a high level. This includes:</p> <ul> <li> Interacting with generic peripheral objects.</li> <li> Task scheduling and program flow.</li> <li> Receiving and sending messages.</li> </ul> <p>The platform layer configures hardware to run the app code. In this layer, you will find:</p> <ul> <li> Concrete peripheral implementations.</li> <li> Peripheral configurations.</li> <li> Initialization functions.</li> </ul> <p>The interface between the app and platform layers is a contract called bindings. This contract declares a handle for each peripheral and function required by the application. The platform binds a configured peripheral or function implementation to each handle.</p>"},{"location":"firmware/architecture/#why-separate-these-layers","title":"Why separate these layers?","text":"<p>There are two major motivations for strictly separating the application and platform code.</p>"},{"location":"firmware/architecture/#motivation-1-platform-abstraction","title":"Motivation 1: Platform Abstraction","text":"<p>Since the application code is not tied to any specific platform, it can run on any platform, provided that platform can fulfill the bindings contract.</p> <p>I cannot overstate how significant this is. Being able to arbitrarily swap platforms enables:</p> <ul> <li> Running vehicle firmware on your local machine through its command line interface.</li> <li> Testing application code with a HIL or SIL setup.</li> <li> Writing portable code, should we ever change our microcontroller.</li> <li> Simultaneously having multiple hardware configurations for the same platform.</li> </ul> <p>Platform abstraction means that each device executes the exact same application code. This greatly simplifies debugging:</p> <ul> <li>If there is a bug when running the vehicle but the test platform works fine, then you immediately know that the vehicle platform layer was configured incorrectly.</li> <li>If all platforms have the same bug, then you know that all hardware peripherals are responding and the bug exists at the app layer.</li> </ul> Debugging Example <p>Imagine you are creating a simple project to turn on an LED whenever a button is pressed (this is the purpose of the <code>Demo/BasicIO</code> project). There are four primary elements of this code:</p> <ol> <li>Read the button state (platform layer).</li> <li>Store the button state in a boolean variable (app).</li> <li>Set the LED with the boolean (platform).</li> <li>Loop to repeat this process indefinitely (app).</li> </ol> <p>Without platform abstraction, if the code \"didn't work\", then you would be wondering:</p> <ul> <li>Does my button circuit work?</li> <li>Is the variable being stored properly?</li> <li>Did I choose the right GPIO pins for the button and LED?</li> <li>Is the LED burnt out?</li> <li>Did my program crash and fail to loop?</li> </ul> <p>Addressing all of these potential errors would lead you down a long road of circuit testing and code modifications, trying to find other ways to see if the LED is working of if there was a crash.</p> <p>Now suppose that you have used platform abstraction. When your project doesn't work, you can quickly configure a CLI platform to emulate the physical button and LED. The button state is \"read\" by prompting for a <code>true</code>/<code>false</code> input and the LED state is \"set\" by printing a message to the screen.</p> <p>When you run the program in the CLI, you may find everything works as expected. When you type <code>true</code>, the program prints \"LED On\" and <code>false</code> causes \"LED Off\", and the program loops as expected. This indicates the the physical hardware was configured incorrectly.</p> <p>Or, maybe the CLI always prints \"LED Off\" regardless of your input. Now you know that there is an error in the app code. You inspect the app code because the error is independent of the platform configuration. </p>"},{"location":"firmware/architecture/#motivation-2-modular-logic","title":"Motivation 2: Modular Logic","text":"<p>Application behaviour can be completely defined without knowledge of the hardware setup, and vice-versa. This means we can develop, test, debug, and optimize a new project before we have the electrical system ready!</p> <p>Alternatively, two developers can work in parallel: one concerned with configuring the hardware and the other with defining app level behaviour. The strict interface between the two layers means they can work independently without breaking each others' code.</p>"},{"location":"firmware/architecture/#implementation","title":"Implementation","text":"<p>Note</p> <p>Unless otherwise mentioned, all paths are relative to the <code>racecar/firmware/</code> directory.</p>"},{"location":"firmware/architecture/#shared-peripheral-interfaces","title":"Shared Peripheral Interfaces","text":"<p>Each peripheral has a platform-independent interface defined as an Abstract Class. This class declares the high-level methods that the application can call on the peripheral. The methods are declared pure virtual and thus have no definition.</p> <p>These peripheral definitions are located in <code>shared/periph</code>.</p>"},{"location":"firmware/architecture/#platform-peripheral-implementations","title":"Platform Peripheral Implementations","text":"<p>Each platform defines a class that inherits from this abstract peripheral class. It must provide a definition for each virtual function defined in the parent class. This child class can use platform-specific logic to accomplish the high-level goal.</p> <p>The peripheral implementations are in the MCAL (Microcontroller Abstraction Layer) folder <code>mcal/&lt;platform-name&gt;/periph/</code>.</p> Interface Example <p>Let us create a simple <code>DigitalInput</code> abstract class and implement it for the <code>stm32f767</code> and <code>CLI</code> platforms.</p> <p>At the app level, <code>DigitalInput</code> has just a single method <code>Read()</code>. This method takes no parameters and should return a boolean indicating the state of the input.</p> shared/periph/gpio.hpp<pre><code>#pragma once\n\nclass DigitalInput {\npublic:\n    virtual bool Read() = 0;\n}\n</code></pre> <p>The <code>virtual</code> specifier allows the <code>Read</code> method to be overridden while the <code>= 0</code> syntax requires the child class to override it by making it a \"pure\" virtual method.</p> <p>To implement this peripheral on the platforms, we inherit from the shared class and override <code>Read</code>.</p> stm32f767 PlatformCLI Platform <p>Digital inputs are read using the stm <code>HAL_GPIO_ReadPin</code> function. This function accepts a port and pin number and returns <code>true</code> (<code>false</code>) if the port pin input is HIGH (LOW).</p> <p>We do not specify a port or pin in this class. They are provided when an object is constructed in the project's platform layer, allowing this class to be reused for any stm32f767 digital input.</p> mcal/stm32f767/periph/gpio.hpp<pre><code>#pragma once\n\n#include &lt;cstdint&gt;\n#include \"shared/periph/gpio.hpp\"\n#include \"stm32f7xx_hal.h\"\n\nnamespace mcal::stm32f {\n\nclass DigitalInput : public shared::periph::DigitalInput {\npublic:\n    DigitalInput(GPIO_TypeDef* gpio_port, uint16_t pin)\n        : port_(gpio_port), pin_(pin) {}\n\n    bool Read() override {\n        return HAL_GPIO_ReadPin(port_, pin_);\n    }\n\nprivate:\n    GPIO_TypeDef* port_;\n    uint16_t pin_;\n};\n}  // namespace mcal::stm32f\n</code></pre> <p>A command line interface does not have physical pins to read but the digital input behaviour can be implemented by prompting the user for a boolean input.</p> mcal/cli/gpio.hpp<pre><code>#pragma once\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include \"shared/periph/gpio.hpp\"\n\nnamespace mcal::cli {\n\nclass DigitalInput : public shared::periph::DigitalInput {\npublic:\n    DigitalInput(std::string name) : name_(name) {}\n\n    bool Read() override {\n        int value;\n        std::cout &lt;&lt; \"Reading DigitalInput \" &lt;&lt; name_ &lt;&lt; std::endl;\n        std::cout &lt;&lt; \" | Enter 0 for False, 1 for True: \";\n        std::cin &gt;&gt; value;\n        std::cout &lt;&lt; \" | Value was \" &lt;&lt; (value ? \"true\" : \"false\") &lt;&lt; std::endl;\n        return value;\n    }\n\nprivate:\n    std::string name_;\n};\n\n}  // namespace mcal::cli\n</code></pre> <p>We allow the developer to give a name to each digital input during construction. This name is included in the input prompt.</p> <p>Suppose a <code>DigitalInput</code> object is constructed with the name <code>\"UserButton\"</code>. When <code>Read()</code> is called for this <code>CLI</code> platform, the user is prompted to enter 0 or 1.</p> <pre><code>Reading DigitalInput UserButton\n| Enter 0 for False, 1 for True: 1\n| Value was true\n</code></pre> <p>With this structure, the developer can write platform-agnostic app level code using the shared <code>DigitalInput</code> interface, knowing that both platforms have a matching implementation.</p> <p>Both the peripheral interface and implementations can be used by multiple projects. To see how they are used in project-specific code, continue to Project Structure.</p>"},{"location":"firmware/architecture/#example-tms-layers","title":"Example: TMS Layers","text":"<p>The TMS functionality is separated into these 2 layers (+ bindings) as follows.</p> <p>This is an example only and does not represent how the actual TMS is configured.</p>"},{"location":"firmware/architecture/#application-layer","title":"Application Layer","text":"<ul> <li>Read the battery temperature with analog sensor <code>temp_sensor</code>.</li> <li>Calculate a fan speed to cool the battery.</li> <li>Control a fan via <code>fan_control</code>.</li> <li>Generate a summary CAN message.</li> <li>Transmit the message over the <code>vehicle_can</code> bus.</li> </ul>"},{"location":"firmware/architecture/#bindings-contract","title":"Bindings Contract","text":"<p>The application needs:</p> <ul> <li>ADC input <code>temp_sensor</code></li> <li>PWM output <code>fan_control</code></li> <li>CAN Bus <code>vehicle_can</code></li> </ul>"},{"location":"firmware/architecture/#platform-layer","title":"Platform Layer","text":"<p>We can run and debug the TMS on any platform satisfying this contract.</p> stm32f767SILCLI <ul> <li><code>temp_sensor</code> = Channel 10 of ADC1</li> <li><code>fan_control</code> = Channel 1 of hardware timer 4</li> <li><code>vehicle_can</code> = CAN2</li> </ul> <p>Functions are executed through the stm32 HAL.</p> <ul> <li><code>temp_sensor</code> = gRPC analog input signal named <code>TempSensor</code></li> <li><code>fan_control</code> = gRPC analog output signal named <code>FanSpeed</code></li> <li><code>vehicle_can</code> = SocketCAN interface called <code>vcan0</code></li> </ul> <p>The project runs on a Raspberry Pi.</p> <ul> <li><code>temp_sensor</code> = Numeric input from the user</li> <li><code>fan_control</code> = Print speed to the screen</li> <li><code>vehicle_can</code> = Print CAN message contents</li> </ul> <p>The project runs in the developer's terminal.</p>"},{"location":"firmware/can-traffic/","title":"Calculating CAN Traffic","text":""},{"location":"firmware/can-traffic/#calculating-can-traffic","title":"Calculating CAN Traffic","text":"<p>In order to calculate the CAN load, we must define a few variables related to the CAN protocol.</p>"},{"location":"firmware/can-traffic/#baud","title":"Baud","text":"<p>The baud rate is the rate at which data is transfered in a communication channel (like CAN). For example, 9600 Baud rate is 9600 bits per second</p>"},{"location":"firmware/can-traffic/#frequency","title":"Frequency","text":"<p>The frequency of a message, expressed in (Hz), is how often a message is transmitted per second. Different messages can have different frequencies.</p> <p>This variation affects the total bits transmitted and, in turn, the bus load. To calculate bits per second, consider each message\u2019s frequency and whether their lengths differ.</p>"},{"location":"firmware/can-traffic/#message-length","title":"Message Length","text":"<p>The message length in a CAN frame can be calculated as a function of the data length. This calculation includes several fixed fields and a variable data field, which changes based on the message's data content.</p> Standard CAN frame bit composition.Adapted from CSS Electronics <p>Each CAN frame consists of several fields with fixed bit lengths, plus a variable-length data field. The total frame length is:</p> \\[ 1 + 11 + 1 + 6 + 8x + 16 + 2 + 7 = 44 + 8x \\text{ bits}\\] <p>where \\(x\\) represents the number of bytes in the data field.</p>"},{"location":"firmware/can-traffic/#total-can-traffic","title":"Total CAN Traffic","text":"<p>We must multiply total bits per second by 1.2 to account for bit stuffing</p> \\[\\begin{align} \\text{Total Bits Per Second} &amp;= 1.2 \\times \\sum_{i=1}^n \\left(\\text{Frequency}_i \\times \\text{Message Length}_i \\right) \\end{align}\\]"},{"location":"firmware/can-traffic/#total-bus-load","title":"Total Bus Load","text":"\\[\\begin{align} \\text{Bus Load}\\% = \\frac{\\text{Total Bits per Second}}{\\text{Baud Rate}} \\times 100\\% \\end{align}\\]"},{"location":"firmware/can-traffic/#sample-calculation","title":"Sample calculation","text":"<p>Given:</p> <p>Baud Rate: 500 kbaud (500,000 bits transferred per second)</p> Message Type Data Length Frequency (Hz) Message Length (Bits) Battery Status 8 100 \\(44 + 8 \\times 8 = 108\\) Motor Control 5 50 \\(44 + 8 \\times 5 = 84\\) \\[\\begin{align} \\text{Total Bits Per Second} &amp;= 1.2 \\times \\sum_{i=1}^n \\left(\\text{Frequency}_i \\times \\text{Message Length}_i \\right)\\\\ \\text{Total Bits Per Second} &amp;= 1.2 \\times \\left((100\\text{ Hz} \\times 108\\text{ bits}) + (50\\text{ Hz} \\times 84\\text{ bits})\\right)\\\\ &amp;= 1.2 \\times \\left(10800 + 4200\\right)\\text{ bits per second}\\\\ &amp;= 1.2 \\times 15000\\text{ bits per second}\\\\ &amp;= 18000\\text{ bits per second} \\end{align}\\] <p>The bus load is the previous example can be calculated as:</p> \\[ \\text{Bus Load}\\% = \\frac{\\text{Total Bits per Second}}{\\text{Baud Rate}} \\times 100\\% \\] \\[ \\text{Bus Load} = \\left(\\frac{18000}{500000}\\right) \\times 100\\% = 3.60\\% \\]"},{"location":"firmware/dev-setup/","title":"Development Environment Setup","text":""},{"location":"firmware/dev-setup/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"firmware/dev-setup/#visual-studio-code","title":"Visual Studio Code","text":"<p>Install it from https://code.visualstudio.com/Download.</p>"},{"location":"firmware/dev-setup/#python","title":"Python","text":"<p>Install the latest Python from https://www.python.org/downloads/. We require version 3.13 or newer. When prompted, add Python to your PATH.</p> <p>Verify its installation by running</p> <pre><code>python --version # on windows\npython3 --version # on Linux/Mac\n</code></pre>"},{"location":"firmware/dev-setup/#platformio","title":"PlatformIO","text":"<p>PlatformIO is a VS Code extension which provides cross-platform support for embedded-systems development.</p> <p>Follow the PlatformIO IDE installation instructions at https://platformio.org/platformio-ide.</p> <p>Install the \"Native\" platform dependencies https://docs.platformio.org/en/latest/platforms/native.html.</p> <p>Optional: You may also install PlatformIO Core for CLI support.</p> <p>Note on C++ Extensions</p> <p>The PlatformIO VS Code extension will automatically install the C/C++ extension to provide language support.</p> <p>Prior to 2025-26, Mac Formula used Clangd for C++ language support. You should disable/uninstall the Clangd extension when working on <code>racecar</code>.</p>"},{"location":"firmware/dev-setup/#stm32cubemx","title":"STM32CubeMX","text":"<p>CubeMX is a program which generates configuration code for our microcontrollers.</p> <ol> <li> <p>Go to www.st.com, click on the account  icon in the top right and create an account. You will need this username and password later on.</p> </li> <li> <p>Download and install STM32CubeMX version 6.15.0 from https://www.st.com/en/development-tools/stm32cubemx.html.</p> </li> </ol> <p>Warning</p> <p>You must install exactly version 6.15.0 (not even 6.15.1). Using a different version than your team members will cause conflicts when opening files.</p>"},{"location":"firmware/dev-setup/#git-github","title":"Git &amp; GitHub","text":"<ol> <li> <p>Create a GitHub account https://github.com/. As a student, you should join GitHub Education https://github.com/education to get benefits like increased storage and free GitHub Actions.</p> </li> <li> <p>Install Git from https://git-scm.com/downloads.</p> </li> <li> <p>(Windows only) Enable symbolic links.</p> <ol> <li>Enable \"Developer Mode\" https://learn.microsoft.com/en-us/windows/apps/get-started/enable-your-device-for-development</li> <li>Run <code>git config --global core.symlinks true</code></li> </ol> </li> </ol> Git Bash (for Windows only) <p>Git Bash is an alternative terminal shell which is installed alongside <code>git</code>. This shell emulates the Linux bash shell, allowing you to use commands like <code>grep</code>, <code>ls</code>, <code>rm</code> and many more on Windows.</p> <p>If you are on Windows, you must use Git Bash as your shell when developing in <code>racecar/</code>. (i.e. not Command Prompt or Powershell).</p> <p>In VS Code, you can change your default shell by pressing F1 and entering <code>&gt;Terminal: Select Default Profile</code> and selecting Git Bash.</p>"},{"location":"firmware/dev-setup/#clone-the-racecar-repository","title":"Clone the <code>racecar</code> Repository","text":"<p>Find our repository on GitHub https://github.com/macformula/racecar.</p> <p>Copy the repository address:</p> <p></p> <p>Navigate to a directory where you want to hold the <code>racecar</code> repo, then run</p> <pre><code>git clone --recurse-submodules https://github.com/macformula/racecar.git\n</code></pre> <p>Choosing a folder</p> <p>Good locations are short and memorable. Consider <code>C:\\formula\\</code> on Windows or <code>~/formula</code> on Linux/Mac.</p> <p>Do not use a directory that has spaces anywhere in its path, such as <code>C:\\Users\\My Files\\Formula</code>. Spaces wreak havoc on automated scripts.</p> <p>Automated Backups</p> <p>Never put Git repo somehwere that is automatically backed-up by another program (ex. OneDrive).</p> <p>Git is itself a backup system, so it will fight with OneDrive and corrupt your local repository.</p>"},{"location":"firmware/dev-setup/#pre-commit","title":"Pre-Commit","text":"<p>We use pre-commit to run formatting and code checks before the code is pushed.</p> <pre><code>pip install pre-commit\n</code></pre> <p>Now go to the <code>racecar/</code> folder and run</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"firmware/dev-setup/#optional-vs-code-extensions","title":"Optional VS Code Extensions","text":"<p>These extensions are not required but will improve your development experience.</p> <ul> <li>Git Graph https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph</li> <li>GitLens https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens</li> </ul> <p>You should now check out Using VS Code and Platformio.</p>"},{"location":"firmware/flashing/","title":"Uploading Firmware to STM","text":""},{"location":"firmware/flashing/#uploading-firmware-to-stm","title":"Uploading Firmware to STM","text":""},{"location":"firmware/flashing/#connect-to-the-board","title":"Connect to the Board","text":"Development Boards + DashboardVehicle ECUs <p>Most development boards (such as the Nucleo-144 and dashboard kit) have built-in ST-Link hardware and a USB interface.</p> <p>Simply connect the board to your laptop with a USB cable.</p> <p></p> ST-Link on Nucleo-144 F767ZI <p></p> <p>The vehicle ECUs are not development boards. They are bare STM32F7 processors soldered to a circuit board. These boards do not have a built-in ST-Link or USB interface so we must use a different connector.</p> <p>You will need and external ST-Link and a USB cable from the blue tool chest in the Hatch bay. Some of the ST-Links are Micro-USB and others are USB-C. We should have cables for both.</p> <p></p> ST-Link and cables are kept in bags in this drawer. Return them when finished! <p></p> <p>Please wrap the ST-Link in electrical tape since it has exposed conductors and is very easy to fry.</p> <p></p> E-Tape would have prevented the Great ST-Link Massacre of Comp '24. <p></p> <ol> <li>Ensure the ECU is off (not receiving power) and the USB is not connected to your laptop.</li> <li> <p>Carefully connect the grey ribbon cable to the ST-Link and the JTAG connector on the ECU board.</p> <p>Both ends of the ribbon cable have a tab which must align with the notch on the connector.</p> <p></p> Connector tab and notch <p></p> </li> <li> <p>Power on the ECU. Talk to an upper year SW or Electrical member for help.</p> </li> <li>Connect your laptop to the ST-Link using the USB cable.</li> </ol> <p>Full setup</p> <p></p> ST-Link issue for Mac Users <p>For some reason, ST-Links don't work when directly connected to a Mac. You need to use a USB hub to indirectly connect to it.</p> <pre><code>flowchart LR\n    Mac --&gt; USB[USB Hub]\n    USB --&gt; ST-Link</code></pre>"},{"location":"firmware/flashing/#upload-with-platformio","title":"Upload with PlatformIO","text":"<p>Open a PlatformIO project in VS Code. Select the STM environment and click upload.</p> <p></p>"},{"location":"firmware/project-structure/","title":"Project Structure","text":""},{"location":"firmware/project-structure/#project-structure","title":"Project Structure","text":"<p>A project is a compilable program that will run on a single device. It should have one <code>main()</code> function. Each ECU in our vehicle has its own project.</p> <p>The simplest project is Blink (see <code>projects/Demo/Blink</code>). This project toggles a digital output indefinitely, toggling the state every 1 second.</p> <p>We will recreate the Blink project from scratch for multiple platforms. You will learn how projects are structured, how to configure an CubeMX for the stm32f767 platform, and how to build and run a project.</p> <pre><code>MyBlink/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 main.cc\n\u251c\u2500\u2500 bindings.hpp\n\u251c\u2500\u2500 CMakeLists.txt\n\u2514\u2500\u2500 platforms/\n    \u251c\u2500\u2500 cli/\n    \u2502   \u251c\u2500\u2500 mcal_conf.cmake\n    \u2502   \u251c\u2500\u2500 bindings.cc\n    \u2502   \u2514\u2500\u2500 CMakeLists.txt\n    \u2514\u2500\u2500 stm32f767/\n        \u251c\u2500\u2500 mcal_conf.cmake\n        \u251c\u2500\u2500 bindings.cc\n        \u251c\u2500\u2500 CMakeLists.txt\n        \u2514\u2500\u2500 cubemx/\n            \u2514\u2500\u2500 board_config.ioc\n</code></pre> <p>Warning</p> <p>Knowledge of our firmware architecture is assumed. Read the Architecture article before continuing.</p> <p>Note</p> <p>Unless otherwise mentioned, all file paths are relative to <code>racecar/firmware</code>.</p>"},{"location":"firmware/project-structure/#prepare-the-project-folder","title":"Prepare the project folder","text":"<p>All projects are stored under the <code>projects/</code> directory, with each project organized in its own folder. Projects can also be grouped into subfolders for better organization. For example, the <code>FrontController</code> project is stored at <code>projects/FrontController/</code>, while demo projects can be grouped under <code>projects/Demo/</code>, such as the <code>Blink</code> project stored at <code>projects/Demo/Blink/</code>.</p> <ol> <li> <p>Create a new folder to hold the project at <code>projects/MyBlink</code>.</p> </li> <li> <p>Add a <code>README.md</code> file explaining the purpose of this project.</p> projects/MyBlink/README.md<pre><code># MyBlink\n\nRecreate the `Demo/Blink` project by following the tutorial at\n&lt;https://macformula.github.io/racecar/firmware/project-structure&gt;.\n</code></pre> </li> <li> <p>Add a <code>platforms/</code> folder to the project. We will populate the platform implementations later.</p> </li> </ol> <p>You should now have the following directory structure.</p> <pre><code>projects/\n\u2514\u2500\u2500 MyBlink/\n    \u251c\u2500\u2500 README.md\n    \u2514\u2500\u2500 platforms/\n</code></pre>"},{"location":"firmware/project-structure/#bindings-contract","title":"Bindings contract","text":"<p>A key feature of our firmware architecture is the complete abstraction of the app-level code from any specific platform implementation (See the Architecture article). The two layers are interfaced by the \"bindings\" contract which we will write first.</p> <p>Create a new file <code>bindings.hpp</code> in the project directory. This is a header file since it only declares the interface objects and methods rather than using or implementing them.</p> projects/MyBlink/bindings.hpp<pre><code>#pragma once\n\nnamespace bindings {\n\n}  // namespace bindings\n</code></pre> <p>Info</p> <p><code>#pragma once</code> Ensures the header file is only ever included once.</p> <p>We use the <code>bindings</code> namespace to indicate that the contained functions and objects form the interface between the app and platform layers.</p> <p>We now add 3 elements to our contract.</p> <ol> <li> <p>A digital output which we will call <code>indicator</code>. Include the <code>shared/periph/gpio.hpp</code> to gain access to the app-level <code>DigitalOutput</code> class.</p> projects/MyBlink/bindings.hpp<pre><code>#pragma once\n\n#include \"shared/periph/gpio.hpp\"\n\nnamespace bindings {\n\nextern macfe::periph::DigitalOutput&amp; indicator;\n\n}  // namespace bindings\n</code></pre> <p>Notice the ampersand <code>&amp;</code> in the type specifier. This makes <code>indicator</code> a reference to a <code>DigitalOutput</code> object. This is necessary since <code>DigitalOutput</code> is a virtual class so its size-in-memory is not defined.</p> </li> <li> <p>A function to wait between toggling. Time delay mechanisms are platform specific and thus must be included in the bindings contract. We will declare a <code>DelayMS</code> function which receives an <code>unsigned int</code> representing the number of milliseconds to delay for.</p> projects/MyBlink/bindings.hpp<pre><code>#pragma once\n\n#include \"shared/periph/gpio.hpp\"\n\nnamespace bindings {\n\nextern macfe::periph::DigitalOutput&amp; indicator;\n\nextern void DelayMS(unsigned int ms);\n\n}  // namespace bindings\n</code></pre> </li> <li> <p>An initialization function. Some platforms must execute initialization code before they are ready to run. For example, stm32f767 has several <code>HAL_*_Init</code> functions which configure the peripherals. We include an <code>Initialize</code> function in bindings so that each platform can define its own behaviour.</p> projects/MyBlink/bindings.hpp<pre><code>#pragma once\n\n#include \"shared/periph/gpio.hpp\"\n\nnamespace bindings {\n\nextern macfe::periph::DigitalOutput&amp; indicator;\n\nextern void DelayMS(unsigned int ms);\nextern void Initialize();\n\n}  // namespace bindings\n</code></pre> </li> </ol> <p>This completes the bindings contract. We can now write the application code, knowing that the platforms will all satisfy this contract.</p>"},{"location":"firmware/project-structure/#application-code","title":"Application code","text":"<p>Our <code>main</code> method is very simple in this project:</p> <ol> <li>Initialize the platform.</li> <li>Turn <code>indicator</code> on.</li> <li>Wait 1 second.</li> <li>Turn <code>indicator</code> off.</li> <li>Wait 1 second.</li> <li>Return to step 2.</li> </ol> <p>Create a <code>main.cc</code> file in the project folder.</p> projects/MyBlink/main.cc<pre><code>#include \"bindings.hpp\"\n\nint main() {\n    bindings::Initialize();\n\n    while (true) {\n        bindings::indicator.SetHigh();\n        bindings::DelayMS(1000);\n        bindings::indicator.SetLow();\n        bindings::DelayMS(1000);\n    }\n\n    return 0;\n}\n</code></pre> <p>In this simple project, all functions and peripherals are inside the <code>bindings</code> namespace. A more complex project could have app-level functions defined in <code>main.cc</code>.</p> <p>The <code>SetHigh</code> and <code>SetLow</code> methods of <code>indicator</code> are declared in the virtual class under <code>shared/periph/gpio.hpp</code>.</p>"},{"location":"firmware/project-structure/#cmake-sources","title":"CMake Sources","text":"<p>Our build system needs help determining which source files to compile. This is configured using a <code>CMakeLists</code> file that adds our <code>main.cc</code> file as a source to the global <code>main</code> target.</p> projects/MyBlink/CMakeLists.txt<pre><code>target_sources(main PUBLIC main.cc)\n</code></pre> <p>This concludes the app-level code. Your project directory should look like</p> <pre><code>projects/\n\u2514\u2500\u2500 MyBlink/\n    \u251c\u2500\u2500 README.md\n    \u251c\u2500\u2500 bindings.hpp\n    \u251c\u2500\u2500 main.cc\n    \u251c\u2500\u2500 CMakeLists.txt\n    \u2514\u2500\u2500 platforms/\n</code></pre>"},{"location":"firmware/project-structure/#platform-code","title":"Platform code","text":"<p>We will create a platform implementation for the command line interface and the stm32f767. Both of these platforms have an MCAL library under <code>racecar/firmware/mcal/</code>.</p>"},{"location":"firmware/project-structure/#command-line-interface","title":"Command Line Interface","text":"<p>Create a <code>cli</code> subfolder of <code>MyBlink/platforms</code>. We will satisfy the bindings contract in a <code>bindings.cc</code> file.</p> <ol> <li> <p>Configure the <code>indicator</code> output. The concrete peripheral implementation is provided by <code>mcal/cli/gpio.hpp</code>. Include this header and create a peripheral.</p> projects/MyBlink/platforms/cli/bindings.cc<pre><code>namespace mcal {\n\ncli::DigitalOutput indicator{\"Indicator\"};\n</code></pre> <p>Now \"bind\" it to the app-level handle in the <code>bindings</code> namespace.</p> projects/MyBlink/platforms/cli/bindings.cc<pre><code>#include &lt;iostream&gt;\n\n#include \"mcal/cli/gpio.hpp\"\n#include \"shared/periph/gpio.hpp\"\n\nnamespace mcal {\n\ncli::DigitalOutput indicator{\"Indicator\"};\n\n}  // namespace mcal\n\nnamespace bindings {\n\n}\n</code></pre> <p>Again, note the ampersand <code>&amp;</code> on the type specifier.</p> </li> <li> <p>Implement <code>DelayMS</code>. Our CLI will use the POSIX <code>usleep</code> function from <code>unistd.h</code>.</p> <p>The <code>usleep</code> delay is measured in microseconds. Multiply our milliseconds parameter by 1000 to convert it to microseconds.</p> projects/MyBlink/platforms/cli/bindings.cc<pre><code>#include \"../../bindings.hpp\"\n\n#include &lt;iostream&gt;\n\n#include \"mcal/cli/gpio.hpp\"\n#include \"shared/periph/gpio.hpp\"\n\nnamespace mcal {\n\ncli::DigitalOutput indicator{\"Indicator\"};\n\n}  // namespace mcal\n\nnamespace bindings {\n\nmacfe::periph::DigitalOutput&amp; indicator = mcal::indicator;\n\nvoid DelayMS(unsigned int ms) {\n    usleep(ms * 1000);\n}\n</code></pre> </li> <li> <p>Implement the <code>Initialize</code> method. Our CLI does not need any initialization, but we can print a message to demonstrate that it is being executed.</p> projects/MyBlink/platforms/cli/bindings.cc<pre><code>#include \"../../bindings.hpp\"\n\n#include &lt;unistd.h&gt;\n\n#include &lt;iostream&gt;\n\n#include \"mcal/cli/gpio.hpp\"\n#include \"shared/periph/gpio.hpp\"\n\nnamespace mcal {\n\ncli::DigitalOutput indicator{\"Indicator\"};\n\n}  // namespace mcal\n\nnamespace bindings {\n\nmacfe::periph::DigitalOutput&amp; indicator = mcal::indicator;\n\nvoid DelayMS(unsigned int ms) {\n    usleep(ms * 1000);\n}\n\nvoid Initialize() {\n    std::cout &lt;&lt; \"Initializing the CLI...\" &lt;&lt; std::endl;\n}\n\n}  // namespace bindings\n</code></pre> </li> </ol> <p>This completes the bindings implementation for the CLI.</p>"},{"location":"firmware/project-structure/#cmake-configuration","title":"CMake Configuration","text":"<p>We must add 2 files to help the build system find the correct sources.</p> projects/MyBlink/platforms/cli/CMakeLists.txt<pre><code>target_sources(bindings PRIVATE bindings.cc)\n\ntarget_link_libraries(bindings PUBLIC mcal-cli)\n</code></pre> <p>The first line adds the <code>bindings.cc</code> file to the globally defined <code>bindings</code> target. The second links the required MCAL library to the target.</p> <p>The second file tells CMake which MCAL library to include.</p> projects/MyBlink/platforms/cli/mcal_conf.cmake<pre><code>set(MCAL cli)\n</code></pre> Historical Note <p>In 2023, the mcal was selected based on the platform folder name rather than by the <code>mcal_conf.cmake</code> file. However, this prevented us from defining two platform implementations using the same mcal, as the two folder names had to be unique but then couldn't reference the same mcal. <code>mcal_conf.cmake</code> was added to allow for this configuration.</p> <p>This conf file duplicates logic in the second line of <code>CMakeLists.txt</code>. Make a PR if you have a better solution.</p> <p>Your <code>projects/MyBlink/platforms</code> directory should look like</p> <pre><code>projects/MyBlink/platforms/\n\u2514\u2500\u2500 cli/\n    \u251c\u2500\u2500 bindings.cc\n    \u251c\u2500\u2500 CMakeLists.txt\n    \u2514\u2500\u2500 mcal_conf.cmake\n</code></pre>"},{"location":"firmware/project-structure/#test-the-cli","title":"Test the CLI","text":"<p>Tip</p> <p>Read the Compiling a Project article for a full explanation of the compilation procedure.</p> <p>To compile the MyBlink project with the CLI platform, open a terminal and navigate to the <code>racecar/firmware</code> directory. Run this command</p> <pre><code>make PROJECT=MyBlink PLATFORM=cli\n</code></pre> <p>This will compile the project to an executable which is stored in the <code>firmware/build/MyBlink/cli</code> directory.</p> <p>Run the executable and see the indicator toggling every 1 second.</p> <pre><code>$ ./build/MyBlink/cli/main.exe\nInitializing the CLI...\nSetting DigitalOutput Channel Indicator to true\nSetting DigitalOutput Channel Indicator to false\nSetting DigitalOutput Channel Indicator to true\nSetting DigitalOutput Channel Indicator to false\n# repeats forever\n</code></pre>"},{"location":"firmware/project-structure/#stm32f767-platform","title":"stm32f767 Platform","text":"<p>See Create a CubeMX Project.</p>"},{"location":"firmware/stm32/bindings/","title":"Binding CubeMX Peripherals to Firmware","text":""},{"location":"firmware/stm32/bindings/#binding-cubemx-peripherals-to-firmware","title":"Binding CubeMX Peripherals to Firmware","text":"<p>Prerequisite Reading</p> <p>This article assumes you are familiar with the <code>racecar/</code> Architecture.</p> <p>It uses the peripheral configuration from the previous article.</p> <p>Open your <code>board_config.ioc</code> file in CubeMX and click \"Generate Code.\" This will surround <code>board_config.ioc</code> with autogenerated files and folders containing C code which initializes the microcontroller using the graphical CubeMX configuration.</p> <p></p> <p>We must lift the generated C functions and variables into C++ and \"bind\" them to our firmware.</p> <p>Start by creating a new file <code>platforms/stm32f767/bindings.cc</code>.</p> platforms/stm32f767/bindings.cc<pre><code>// ============================== CubeMX Includes ==============================\n#include \"main.h\"\n#include \"stm32f7xx_hal.h\"\n\nextern \"C\" {\n// This requires extern since it is not declared in a header, only defined in\n// cubemx/../main.c\nvoid SystemClock_Config();\n}\n\n// ============================= Firmware Includes =============================\n#include \"../../bindings.hpp\"\n\n// =============================== MCAL Namespace ==============================\nnamespace mcal {\nusing namespace mcal::periph::stm32f;\n// --------- Define C++ peripheral objects from CubeMX generated code ----------\n\n}  // namespace mcal\n\n// ============================ Bindings Namespace =============================\nnamespace bindings {\n// ------------- Bind mcal peripherals to the bindings.hpp handles -------------\n\n// ---------------- Implement other platform-specific functions ----------------\nvoid Initialize() {\n    HAL_Init();            // from stm32f7xx_hal.h\n    SystemClock_Config();  // from cubemx/src/main.c\n\n    // ------------------ Add additional initialization code -------------------\n}\n\n}  // namespace bindings\n</code></pre> Where is <code>bindings.hpp</code>? <p>We created <code>bindings.hpp</code> in the project structure article, but you will need to recreate it for each project.</p> <p>Use the following <code>bindings.hpp</code> to continue the LV Controller example from the MCU Configuration article. Place it in the project folder (adjacent to <code>main.cc</code>, NOT in any platform folder).</p> bindings.hpp<pre><code>// This file is for illustrative purposes only and does not indicate the\n// complete or correct LV Controller code.\n\n#include \"shared/periph/analog_input.hpp\"\n#include \"shared/periph/can.hpp\"\n#include \"shared/periph/gpio.hpp\"\n\nnamespace bindings {\n\nextern macfe::periph::DigitalOutput&amp; tssi_red_en;\nextern macfe::periph::DigitalOutput&amp; tssi_green_en;\n\nextern macfe::periph::AnalogInput&amp; dcdc_sense;\nextern macfe::periph::AnalogInput&amp; suspension_travel3;\nextern macfe::periph::AnalogInput&amp; suspension_travel4;\n\nextern macfe::periph::CanBase&amp; veh_can_base;\n\n// Note: JTAG isn't used in any of our code, but the CubeMX pin configuration is\n// still necessary.\n\nextern void Initialize();\n\n}  // namespace bindings\n</code></pre>"},{"location":"firmware/stm32/bindings/#initialization","title":"Initialization","text":"<p>CubeMX generates functions to initialize the MCU according to our configuration, but we are responsible for calling them at the start of our program.</p> <p>The app-level cannot call these functions since it must be platform-independent. To get around this, we let each platform define a <code>void Initialize()</code> function to call its startup code. So far, our <code>Initialize()</code> sets up the HAL and clock, but each peripheral will add to it.</p>"},{"location":"firmware/stm32/bindings/#peripherals","title":"Peripherals","text":"<p>A C++ peripheral is created by wrapping the generated variables in an MCAL peripheral class.</p> <p>For each hardware peripheral that you use (ex GPIO, ADC1, CAN2):</p> <ol> <li>Include <code>&lt;periph&gt;.h</code> (generated by CubeMX) to access the initialization functions.</li> <li>Call <code>MX_&lt;PERIPH&gt;_INIT()</code> in <code>Initialize()</code>.</li> <li>Include the <code>mcal/stm32f/periph/&lt;periph&gt;.hpp</code> to access the <code>racecar/</code> peripheral class.</li> </ol> <p>Then for each peripheral instance of that type (ex <code>TSSI_RED_EN</code> and <code>TSSI_GN_EN</code> GPIOs):</p> <ol> <li>Define C++ peripheral in the <code>mcal::</code> namespace using the constants and handles generated by CubeMX.</li> <li>Bind the <code>mcal::</code> object to the <code>shared::</code> handle inside the <code>bindings</code> namespace.</li> </ol>"},{"location":"firmware/stm32/bindings/#digital-inputoutput-gpio","title":"Digital Input/Output (GPIO)","text":"<p>Construct an stm32 <code>DigitalOutput</code> or <code>DigitalInput</code> with the <code>&lt;NAME&gt;_GPIO_Port</code> and <code>&lt;NAME&gt;_Pin</code> constants defined in CubeMX's <code>main.h</code>.</p> <p>CubeMX generates these constants based on the pin configurations. For example, <code>TSSI_RED_EN</code> is connected to PC2, thus CubeMX generates</p> cubemx/inc/main.h<pre><code>#define TSSI_RED_SIG_GPIO_Port GPIOC\n#define TSSI_RED_SIG_Pin GPIO_PIN_2\n</code></pre> bindings.cc<pre><code>// ============================== CubeMX Includes ==============================\n#include \"gpio.h\"\n#include \"main.h\"\n#include \"stm32f7xx_hal.h\"\n\nextern \"C\" {\n// This requires extern since it is not declared in a header, only defined in\n// cubemx/../main.c\nvoid SystemClock_Config();\n}\n\n// ============================= Firmware Includes =============================\n#include \"../../bindings.hpp\"\n#include \"mcal/stm32f/periph/gpio.hpp\"\n\n// =============================== MCAL Namespace ==============================\nnamespace mcal {\nusing namespace mcal::periph::stm32f;\n// --------- Define C++ peripheral objects from CubeMX generated code ----------\n\nDigitalOutput tssi_red_en{TSSI_RED_SIG_GPIO_Port, TSSI_RED_SIG_Pin};\nDigitalOutput tssi_green_signal{TSSI_GN_SIG_GPIO_Port, TSSI_GN_SIG_Pin};\n\n}  // namespace mcal\n\n// ============================ Bindings Namespace =============================\nnamespace bindings {\n// ------------- Bind mcal peripherals to the bindings.hpp handles -------------\nmacfe::periph::DigitalOutput&amp; tssi_red_en = mcal::tssi_red_en;\nmacfe::periph::DigitalOutput&amp; tssi_green_en = mcal::tssi_green_en;\n\n// ---------------- Implement other platform-specific functions ----------------\nvoid Initialize() {\n    HAL_Init();            // from cubemx/inc/stm32f7xx_hal.h\n    SystemClock_Config();  // from cubemx/src/main.c\n\n    // ------------------ Add additional initialization code -------------------\n    MX_GPIO_Init();  // from cubemx/inc/gpio.h\n}\n\n}  // namespace bindings\n</code></pre>"},{"location":"firmware/stm32/bindings/#analog-input-adc","title":"Analog Input (ADC)","text":"<p>Unlike with GPIO pins, CubeMX does not include the ADC name in the generated handles. You must manually align the ADC peripheral number (ADC1, ADC2, or ADC3) and channel for each peripheral.</p> <p>For example, <code>DCDC_SNS</code> was connected to <code>ADC1_IN10</code>, so we must pass the pointer to the ADC1 handle <code>&amp;hadc1</code> along with the channel 10 constant.</p> <p>Note that each ADC# has its own <code>MX_ADC#_Init()</code> function.</p> bindings.cc<pre><code>// ============================== CubeMX Includes ==============================\n#include \"adc.h\"\n#include \"gpio.h\"\n#include \"main.h\"\n#include \"stm32f7xx_hal.h\"\n\nextern \"C\" {\n// This requires extern since it is not declared in a header, only defined in\n// cubemx/../main.c\nvoid SystemClock_Config();\n}\n\n// ============================= Firmware Includes =============================\n#include \"../../bindings.hpp\"\n#include \"mcal/stm32f/periph/analog_input.hpp\"\n#include \"mcal/stm32f/periph/gpio.hpp\"\n\n// =============================== MCAL Namespace ==============================\nnamespace mcal {\nusing namespace mcal::periph::stm32f;\n// --------- Define C++ peripheral objects from CubeMX generated code ----------\n\nDigitalOutput tssi_red_en{TSSI_RED_SIG_GPIO_Port, TSSI_RED_SIG_Pin};\nDigitalOutput tssi_green_signal{TSSI_GN_SIG_GPIO_Port, TSSI_GN_SIG_Pin};\n\nAnalogInput dcdc_sense{&amp;hadc1, ADC_CHANNEL_10};\nAnalogInput suspension_travel3{&amp;hadc1, ADC_CHANNEL_15};\nAnalogInput suspension_travel4{&amp;hadc1, ADC_CHANNEL_14};\n\n}  // namespace mcal\n\n// ============================ Bindings Namespace =============================\nnamespace bindings {\n// ------------- Bind mcal peripherals to the bindings.hpp handles -------------\nmacfe::periph::DigitalOutput&amp; tssi_red_en = mcal::tssi_red_en;\nmacfe::periph::DigitalOutput&amp; tssi_green_en = mcal::tssi_green_en;\n\nmacfe::periph::AnalogInput&amp; dcdc_sense = mcal::dcdc_sense;\nmacfe::periph::AnalogInput&amp; suspension_travel3 = mcal::suspension_travel3;\nmacfe::periph::AnalogInput&amp; suspension_travel4 = mcal::suspension_travel4;\n\n// ---------------- Implement other platform-specific functions ----------------\nvoid Initialize() {\n    HAL_Init();            // from cubemx/inc/stm32f7xx_hal.h\n    SystemClock_Config();  // from cubemx/src/main.c\n\n    // ------------------ Add additional initialization code -------------------\n    MX_GPIO_Init();  // from cubemx/inc/gpio.h\n    MX_ADC1_Init();  // from cubemx/inc/adc.h\n}\n\n}  // namespace bindings\n</code></pre>"},{"location":"firmware/stm32/bindings/#can","title":"CAN","text":"<p>Connect the CAN handle to the peripheral.</p> <p>As with ADC, each CAN# has its own <code>MX_CAN#_Init()</code> function.</p> bindings.cc<pre><code>// ============================== CubeMX Includes ==============================\n#include \"adc.h\"\n#include \"can.h\"\n#include \"gpio.h\"\n#include \"main.h\"\n#include \"stm32f7xx_hal.h\"\n\nextern \"C\" {\n// This requires extern since it is not declared in a header, only defined in\n// cubemx/../main.c\nvoid SystemClock_Config();\n}\n\n// ============================= Firmware Includes =============================\n#include \"../../bindings.hpp\"\n#include \"mcal/stm32f/periph/analog_input.hpp\"\n#include \"mcal/stm32f/periph/can.hpp\"\n#include \"mcal/stm32f/periph/gpio.hpp\"\n\n// =============================== MCAL Namespace ==============================\nnamespace mcal {\nusing namespace mcal::periph::stm32f;\n// --------- Define C++ peripheral objects from CubeMX generated code ----------\n\nDigitalOutput tssi_red_en{TSSI_RED_SIG_GPIO_Port, TSSI_RED_SIG_Pin};\nDigitalOutput tssi_green_signal{TSSI_GN_SIG_GPIO_Port, TSSI_GN_SIG_Pin};\n\nAnalogInput dcdc_sense{&amp;hadc1, ADC_CHANNEL_10};\nAnalogInput suspension_travel3{&amp;hadc1, ADC_CHANNEL_15};\nAnalogInput suspension_travel4{&amp;hadc1, ADC_CHANNEL_14};\n\nCanBase veh_can_base{&amp;hcan2};\n\n}  // namespace mcal\n\n// ============================ Bindings Namespace =============================\nnamespace bindings {\n// ------------- Bind mcal peripherals to the bindings.hpp handles -------------\nmacfe::periph::DigitalOutput&amp; tssi_red_en = mcal::tssi_red_en;\nmacfe::periph::DigitalOutput&amp; tssi_green_en = mcal::tssi_green_en;\n\nmacfe::periph::AnalogInput&amp; dcdc_sense = mcal::dcdc_sense;\nmacfe::periph::AnalogInput&amp; suspension_travel3 = mcal::suspension_travel3;\nmacfe::periph::AnalogInput&amp; suspension_travel4 = mcal::suspension_travel4;\n\nmacfe::periph::CanBase&amp; veh_can_base = mcal::veh_can_base;\n\n// ---------------- Implement other platform-specific functions ----------------\nvoid Initialize() {\n    HAL_Init();            // from cubemx/inc/stm32f7xx_hal.h\n    SystemClock_Config();  // from cubemx/src/main.c\n\n    // ------------------ Add additional initialization code -------------------\n    MX_GPIO_Init();  // from cubemx/inc/gpio.h\n    MX_ADC1_Init();  // from cubemx/inc/adc.h\n    MX_CAN2_Init();  // from cubemx/inc/can.h\n}\n\n}  // namespace bindings\n</code></pre>"},{"location":"firmware/stm32/configure/","title":"Configure a Microcontroller in CubeMX","text":""},{"location":"firmware/stm32/configure/#configure-a-microcontroller-in-cubemx","title":"Configure a Microcontroller in CubeMX","text":"<p>A microcontroller needs to interact with sensors, outputs, and communication interfaces. CubeMX helps us configure and visualize these peripherals.</p> <p>In this tutorial, we will configure digital outputs, analog inputs, CAN, and JTAG on an stm32f767 microcontroller.</p> <p>Note</p> <p>This article assumes that you have a CubeMX project from the previous tutorial.</p>"},{"location":"firmware/stm32/configure/#electrical-schematic-and-pinout","title":"Electrical Schematic and Pinout","text":"<p>Our microcontrollers are soldered to a PCB with fixed electrical connections to the peripherals, so you should have the relevant electrical schematic handy (talk to the electrical subteam to get this).</p> <p>We will configure part of the LV Controller circuit. The big yellow block is part of the microcontroller and every pin that doesn't have an  needs to be handled.</p> <p></p>"},{"location":"firmware/stm32/configure/#pin-configuration","title":"Pin Configuration","text":"<p>Open the <code>board_config.ioc</code> file in CubeMX. Go to the \"Pinout &amp; Configuration\" tab. This is where you spend most of your time.</p>"},{"location":"firmware/stm32/configure/#digital-outputs","title":"Digital Outputs","text":"<p>The <code>TSSI_GN_SIG</code> and <code>TSSI_RED_SIG</code> are digital outputs which control the green and red lights of the TSSI.</p> <p>The red signal is controlled by a digital output on pin PC2. Use the lower-right search field to find the pin.</p> <p></p> <p>Click on the PC2 label and select <code>GPIO Output</code>.</p> <p></p> <p>PC2 is now a GPIO output, but we should give it a descriptive name. Expand the <code>System Core</code> menu on the left and click <code>GPIO</code>. Select the PC2 pin and enter <code>TSSI_RED_SIG</code> in the user label. You can usually leave the other configuration settings at their default.</p> <p></p> <p>Now repeat this process for the <code>TSSI_GN_SIG</code>! Check the schematic for its pin number (PC3) and give it a label.</p>"},{"location":"firmware/stm32/configure/#analog-inputs-adc","title":"Analog Inputs (ADC)","text":"<p>Many sensors produce a voltage related to the measured value. We need to configure a pin to read this analog voltage before firmware can calculate the measured value.</p> <p><code>DCDC_SNS</code> measures the electrical current from the high voltage battery to the low voltage circuit. Let's create an ADC input to read this value so that firmware can ensure enough power is being supplied.</p> <p>Search for PC0 and set it to <code>ADC1_IN10</code></p> <p></p> <p>See Section 15 of <code>racecar/datasheets/stm/RM0410</code> for an explanation of the STM Analog to Digital converters and their channels.</p> <p>To name the pin, go to <code>Analog -&gt; ADC1 -&gt; GPIO Settings</code>, click on PC0, and enter a label.</p> <p></p> <p>In the future, you may need to modify the ADC \"Parameter Settings\" but we will ignore that for now.</p> <p>The <code>DCDC_SNS</code> input is ready to ready voltages!</p> <p>The LV Controller schematic also has two sensors <code>STP3_SIG</code> and <code>STP4_SIG</code> to measure suspension travel position. The output voltage is proportional to how compressed the suspension is. Repeat this process for those two inputs using the <code>ADC1</code> channels.</p>"},{"location":"firmware/stm32/configure/#can","title":"CAN","text":"<p>All the vehicle ECUs communicate over the CAN bus. We must configure both the receive (RX) and transmit (TX) pins.</p> <p>A CAN bus has 2 wires: CAN High and CAN Low, but these signals do not connect directly to the microcontroller. Instead, the MCU has CAN RX and CAN TX which connect to a CAN transceiver that interfaces with the bus wires.</p> <p>STM32F767 supports 3 CAN buses. LV Controller connects using the CAN2 peripheral. Search for PC5 and set its state to <code>CAN2_RX</code>.</p> <p></p> <p>CubeMX recognizes that RX and TX come in pairs and automatically sets PB13 to <code>CAN2_TX</code>.</p> <p></p> <p>Clock Config</p> <p>All devices on a CAN bus must agree on the same \"baud rate\" i.e. transmission frequency. Our vehicle uses 500 kbit/s. We must speed up the internal MCU clock to support this.</p> <p>Switch to the \"Clock Configuration\" tab. Change the clock source in <code>System Clock Mux</code> to PLLCLK and <code>APB1 Prescaler</code> to /2.</p> <p></p> <p>Back in the \"Pinout &amp; Configuration\" tab, open \"Connectivity \u2192 CAN2 \u2192 Parameter Settings.\" Under \"Bit Timings Parameters\", set</p> <ul> <li>Prescaler (for Time Quantum) = <code>6</code></li> <li>Time Quanta in Bit Segment 1 = <code>13 Times</code></li> <li>Time Quanta in Bit Segment 2 = <code>2 Times</code></li> </ul> <p>Verify that the calculated baud rate is 500 000 bit/s.</p> <p></p> <p>Finally, under NVIC Settings, enable the <code>RX0</code> interrupt.</p> <p></p> <p>Important</p> <p>This step is very important. Without enabling the <code>RX0</code> interrupt, your ECU will not be able to receive CAN messages!</p>"},{"location":"firmware/stm32/configure/#jtag-connector","title":"JTAG Connector","text":"<p>The only remaining pins are the JTAG connector pins which enable programming and debugging.</p> <p>Set PB4 to <code>SYS_JTRST</code>. This should automatically configure 4 other pins, including PB3 to <code>SYS_JTDO-SWO</code>.</p> <p>Pins PA13, PA14 and PA15 are not shown in this part of the schematic. CubeMX's automatic configuration for them is correct.</p> <p></p> <p>We do not need to further configure or rename the JTAG pins, we only need to tell the MCU that they exist.</p>"},{"location":"firmware/stm32/configure/#conclusion","title":"Conclusion","text":"<p>We are now done configuring the pins in this schematic! We will now bind the generated C code to our firmware in the final tutorial.</p> <p></p>"},{"location":"firmware/stm32/start-cubemx-project/","title":"Start a CubeMX Project","text":""},{"location":"firmware/stm32/start-cubemx-project/#start-a-cubemx-project","title":"Start a CubeMX Project","text":"<p>STM32CubeMX is a graphical software which generates code to configure an STM32 Microcontroller.</p> <p>The project must be configured correctly to fit our build system.</p> <p>Tip</p> <p>Click on an image to enlarge it.</p>"},{"location":"firmware/stm32/start-cubemx-project/#create-a-new-project","title":"Create a new project","text":"<p>Open CubeMX and start a new project.</p> <p></p> <p>In the \"MCU/MPU Selector\" tab, search for the microcontroller. Most of MAC FSAE boards are <code>STM32F767ZIT6</code>. Select the board and click \"Start Project.\"</p> <p>Info</p> <p>If you are using a \"discovery board\" like a Nucleo or the dashboard's STM32F469-DISCO, search for the board under \"Board Selector\" as this will configure many of the IO for the board's hardware.</p> <p></p> <p>When prompted about Memory Protection, select \"Yes.\" If asked, initialize all peripherals in their default mode.</p> <p></p> <p>Do not save!</p> <p>CubeMX will now create your new project but do not save it yet! Some settings cannot be changed after the first save.</p>"},{"location":"firmware/stm32/start-cubemx-project/#configure-project-settings","title":"Configure project settings","text":"<p>Go to the \"Project Manager \u2192 Project\" tab and configure the \"Project Settings\":</p> <ul> <li>Project Name = <code>board_config</code></li> <li> <p>Project Location = Browse and select <code>racecar/firmware/projects/&lt;PROJECT&gt;/platforms/stm32f767</code></p> <p>Replace <code>&lt;PROJECT&gt;</code> with your project folder created in this tutorial.</p> <p><code>stm32f767</code> can be changed as appropriate.</p> </li> <li> <p>Application Structure = <code>Basic</code></p> </li> <li>Check <code>Do not generate main()</code></li> <li>Toolchain Folder Location = leave as is.</li> <li>Toolchain / IDE = <code>CMake</code></li> </ul> <p></p> <p>You can ignore the Linker, Thread-safe, and Package settings sections.</p> <p>Configure \"Project Manager \u2192 Code Generator \u2192 Generated files\"</p> <ul> <li>Check <code>Generate peripheral initialization as a pair of '.c/.h' files</code></li> <li>Uncheck <code>Backup previously generate files</code></li> <li>Uncheck <code>Keep User Code</code></li> <li> <p>Check <code>Delete previously generated files</code></p> <p>Info</p> <p>CubeMX generates C files which you can add code to, but our Architecture works at a higher level. Therefore, we do not support adding code to the generated files. Unchecking these settings enforces this rule since user code will be removed.</p> </li> </ul> <p></p> <p>Save Now</p> <p>You can now save the project. Click \"File \u2192 Save Project\" or Ctrl+S.</p>"},{"location":"firmware/stm32/start-cubemx-project/#build-system-integration","title":"Build system integration","text":"<p>Close CubeMX and open the Project Location we set earlier. You should see <code>platforms/stm32f767/board_config/board_config.ioc</code>. Rename the <code>board_config/</code> folder to <code>cubemx/</code> but do not rename the <code>board_config.ioc</code> file.</p> Why do we do this? <p>We shouldn't need to. The CMake build system is hardcoded to look for a <code>board_config.ioc</code> file in a <code>cubemx/</code> folder.</p> <p>If you want to write a better CMake function which takes the folder/filename as parameters, please be my guest. (Don't forget to update these docs afterwards!)</p> <p>Create a <code>.gitignore</code> file to ignore all generated files in the <code>cubemx/</code> folder. We only track the <code>.ioc</code> configuration file and let CubeMX regenerate the code files locally.</p> platforms/stm32f767/cubemx/.gitignore<pre><code># Do not track any files generated by STM32CubeMX.\n*\n!.gitignore\n!*.ioc\n</code></pre> <p>Create an <code>mcal_conf.cmake</code> file for the platform to inform the build system of how to generate the CubeMX code at build time.</p> platforms/stm32f767/mcal_conf.cmake<pre><code>set(MCAL stm32f)\ninclude(${CMAKE_SOURCE_DIR}/cmake/build_cubemx.cmake)\nadd_compile_definitions(STM32F7)\n</code></pre> <p>The <code>set(MCAL ...)</code> command is required in any platform's <code>mcal_conf</code>.</p> <p>The second line is unique to <code>stm32</code> platforms, providing CubeMX generation and the <code>arm-none-eabi</code> toolchain.</p> <p>The third line specifies which stm32f-series board to use. It changes which headers are included in the <code>mcal/</code> folder. You would define <code>STM32F4</code> on the Dashboard, for example.</p> <p>Finally, create a CMakeLists with commands to link the CubeMX code to our <code>main</code> executable.</p> platforms/stm32f767/CMakeLists.txt<pre><code>target_sources(main PRIVATE bindings.cc)\ntarget_link_libraries(main PRIVATE mcal-stm32f)\n\nadd_subdirectory(cubemx/cmake/stm32cubemx)\ntarget_link_libraries(main PRIVATE stm32cubemx)\n</code></pre> <p>Note</p> <p><code>bindings.cc</code> doesn't exist yet, see the next tutorial.</p> <p>Your CubeMX project is now ready to be compiled within <code>racecar/</code>! But the microcontroller hasn't been configured to do anything yet. Let's change that in the next tutorial.</p>"},{"location":"firmware/using-vscode-pio/","title":"Using VS Code and PlatformIO","text":""},{"location":"firmware/using-vscode-pio/#using-vs-code-and-platformio","title":"Using VS Code and PlatformIO","text":""},{"location":"firmware/using-vscode-pio/#openning-a-project","title":"Openning a Project","text":"<p>Open a new VS Code window. Go to the Platform IO homepage by clicking the  icon in the Status Bar.</p> <p></p> I don't see the  <p>You can alternatively open the PlatformIO homepage running the Command Palette with F1 then typing <code>PlatformIO: PlatformIO Home</code>.</p> <p>From PlatformIO Home, click Open Project and open <code>racecar/projects/demo/blink</code>.</p> <p></p> <p></p> <p>You should now see the files and folders in for the <code>blink</code> project.</p> <p></p>"},{"location":"firmware/using-vscode-pio/#project-structure","title":"Project Structure","text":"<p>Every project uses the same structure, so let's explore the itema in the <code>demo/blink</code> project. Click on a file to open it in the VS Code window.</p> platformio.iniREADME.mdsrc/include/lib/.pio and .vscode <p>This file describes how to compile the project.</p> <pre><code>[platformio]\nname = \"Blink\"\ndescription = \"A simple program to toggle a digital output.\"\n\n[env]\n... # omitted for simplicity\n\n[common]\n...\n\n[env:stm32f767]\n...\n\n[env:stm32f469]\n...\n\n[env:cli]\n...\n\n[env:linux]\n...\n</code></pre> <p>PlatformIO uses environments to let you define different compilation instructions for different platforms.</p> <p>This file shows that the Blink project is defined for 4 environments: STM32F767, STM32F469, a generic Command Line Interface, and the Linux CLI.</p> What is the difference between the Linux and Generic CLI environments? <p>Linux computers have certain features that aren't available on Windows and Mac, namely it supports CAN at the kernel layer (see https://netmodule-linux.readthedocs.io/en/latest/howto/can.html).</p> <p>This means that projects using CAN are better simulated on a Linux machine. The Blink project doesn't use CAN, so there is no difference.</p> <p>Whenever you see a README file, read it! It provides useful information about the code around it.</p> <p></p> <p>This folder contains the project \"source code\" (hence \"src\"), which is C and C++ code that tells the processor what to do.</p> <p></p> <p>Every project has a <code>main.cc</code> file with a <code>main()</code> function. This is where the program starts. Other projects may have more <code>.cc</code> files.</p> <p>The <code>src/</code> folder also has a <code>platforms/</code> folder, with one subfolder per environment. This subfolder connects the abstract <code>main</code> code to a specific environment platform.</p> <p>Finally, there is a symlink to <code>racecar/lib/mcal</code>. MCAL stands for \"Micro-Controller Abstraction Layer,\" more on that in Architecture.</p> What is a symlink? <p>A symlink (symbolic link) is a \"link\" to another file or folder. It lets you easily reference far-away files.</p> <p>In our case, we write the <code>mcal</code> code once, in <code>racecar/lib/mcal</code>, but want all projects to use it. A symlink lets each project reference the same <code>mcal</code>.</p> <p>These are C++ header files which don't contain source code themselves, but are \"included\" by other source files in <code>src/</code></p> <p></p> <p>Library code is code which we write once for use in many projects. Each project's <code>lib/</code> folder contains symlinks to folders <code>racecar/lib</code> depending on which shared code it needs to use.</p> <p>For example, if you want to use a Lookup Table in a project, you would add a symlink to <code>racecar/lib/lookup_table</code>.</p> <p></p> <p>These are \"hidden\" folders managed by PlatformIO. You should not edit them.</p>"},{"location":"firmware/using-vscode-pio/#building-and-uploading-with-platformio","title":"Building and Uploading with PlatformIO","text":"<p>First, select which environment / platform you'd like to compile for. Since the Blink project supports CLI, we will be able to run it in our terminal, so let's select the <code>cli</code> environment.</p> <p></p> <p>PlatformIO will quickly reconfigure itself for the new environment.</p> <p>Click the Build button  to build / compile the project. PlatformIO will open a window and display progress and any errors.</p> <p>The first build may be slow since PlatformIO needs to install dependencies for each project and environment. Successive builds will be much faster.</p> <p></p> <p>Click the Upload button  to run the Blink program in your CLI.</p> <p></p> <p>To upload to STM, see Uploading Firmware to STM.</p>"},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/#tutorials","title":"Tutorials","text":"<p> Virtual CAN on WSL2</p> <p> SSH and Commit Signing</p> <p> Monitor CAN Bus with Busmaster</p> <p>Orion BMS</p> <p> Editing this site</p>"},{"location":"tutorials/git/","title":"Git and GitHub","text":""},{"location":"tutorials/git/#git-and-github","title":"Git and GitHub","text":"<p>This page will be implemented in #146. Feel free to take it on.</p>"},{"location":"tutorials/site-dev/","title":"Editing this site","text":""},{"location":"tutorials/site-dev/#editing-this-site","title":"Editing this site","text":"<p>We use Material for MkDocs to generate beautiful documentation without worrying about the intricacies of modern web development. The content is written with Markdown which has a low learning curve for anyone not already familiar with it.</p> <p>The site is hosted with GitHub Pages.</p>"},{"location":"tutorials/site-dev/#environment-setup","title":"Environment Setup","text":"<p>These steps only need to be performed once.</p> <ol> <li> <p>Clone the racecar repository.</p> <pre><code>git clone https://github.com/macformula/racecar.git\n</code></pre> </li> <li> <p>Create a Python virtual environment.</p> <p>This step is optional but recommended.</p> <pre><code>cd racecar/docs\npython -m venv .venv\n</code></pre> <p>Activate the virtual environment.</p> WindowsUnix <pre><code>.venv\\Scripts\\activate\n</code></pre> <pre><code>source .venv/bin/activate\n</code></pre> </li> <li> <p>Install the documentation dependencies.</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> </ol>"},{"location":"tutorials/site-dev/#editing-and-viewing-the-site","title":"Editing and Viewing the Site","text":"<p>Follow these steps each time you want to edit the site.</p> <p>This section assumes that you have already activated your virtual environment, if applicable.</p> <ol> <li> <p>Launch an <code>mkdocs</code> server to locally host the site.</p> <pre><code>$ cd racecar/docs\n$ mkdocs serve\n...\nINFO    -  [22:01:58] Serving on http://127.0.0.1:8000/\n</code></pre> </li> <li> <p>Open the listed URL in your web browser.</p> <p>In this example, open http://127.0.0.1:8000/ in a browser.</p> </li> <li> <p>Edit the contents of the <code>docs/</code> folder. Your locally hosted site will update whenever you edit and save a relevant file.</p> <p>Markdown References</p> <p>Generic Markdown https://www.markdownguide.org/cheat-sheet/</p> <p>Material for MkDocs https://squidfunk.github.io/mkdocs-material/reference/</p> </li> </ol>"},{"location":"tutorials/site-dev/#publishing-changes","title":"Publishing Changes","text":"<p>When you are satisfied with your changes, commit and make a pull request.</p> <p>A Github action will automatically re-build the website when the PR is merged into <code>main</code>. The build artefacts are pushed to the <code>ghpages</code> branch of the repository from which the website is hosted. The website will update within a few minutes.</p> <p>The action is specified in <code>racecar/.github/workflows/deploy-ghpages.yml</code> and was copied from https://squidfunk.github.io/mkdocs-material/publishing-your-site/.</p> <p>The <code>ghpages</code> branch</p> <p>The action force-pushes build artefacts to the <code>ghpages</code> branch, so any changes made on this branch will be overwritten. Edit the contents of <code>racecar/docs</code> to modify the site.</p>"},{"location":"tutorials/busmaster/","title":"Monitor CAN Bus with Busmaster","text":""},{"location":"tutorials/busmaster/#monitor-can-bus-with-busmaster","title":"Monitor CAN Bus with Busmaster","text":""},{"location":"tutorials/busmaster/#you-will-need","title":"You will need","text":"<ul> <li> <p>Busmaster software v3.2.2 https://rbei-etas.github.io/busmaster/</p> </li> <li> <p>Kvaser Drivers https://kvaser.com/download/</p> <p>Kvaser drivers are only available for Windows and Linux, so you cannot follow this tutorial on MacOS.</p> </li> <li> <p>The Kvaser USB CAN adapter (which should be kept in the bay).</p> <p></p> </li> </ul>"},{"location":"tutorials/busmaster/#physical-connections","title":"Physical Connections","text":"<ol> <li>Connect the USB port the Kvaser to your computer.</li> <li> <p>Connect the D-Sub port of the Kvaser to the CAN port.</p> Vehicle CAN PortsTestbench CAN Port <p>Located on the underside of the dashboard. One port for the <code>VEH</code> CAN bus and one for <code>POWERTRAIN</code>.</p> <p> </p> <p>Only the <code>VEH</code> CAN bus is available.</p> <p></p> </li> </ol>"},{"location":"tutorials/busmaster/#busmaster-setup","title":"Busmaster Setup","text":"<p>Open Busmaster. Under \"Driver Selection\" choose \"Kvaser CAN.\"</p> <p></p> <p>Under \"Channel Configuration,\" configure a Kvaser channel by selecting it on the left and clicking the <code>&gt;&gt;</code> button. Configure the BaudRate to 500 000 bps.</p> <p></p> Kvaser channel numbering <p>The Kvaser has 2 D-Sub connectors to support 2 CAN channels / busses. The cables are labelled Ch.1 and Ch.2, but they appear in Busmaster configuration as Channel 0 and Channel 1, respectively.</p> <p></p> <p>However, once you start reading CAN messages, they are correctly numbered 1 and 2 again (see next image).</p> <p>Click \"Connect\" in the top-left to start viewing CAN messages!</p> <p></p> <p>The raw binary CAN messages are hard to read. In the next section we will associate a CAN database to allow Busmaster to decode for us.</p>"},{"location":"tutorials/busmaster/#interpret-can-messages","title":"Interpret CAN Messages","text":"<p>Busmaster only accepts a special <code>.dbf</code> database format. Fortunately, it provides a tool to convert our <code>.dbc</code> files to <code>.dbf</code>.</p> <p>Under \"Tools\" select \"Format Converter.\"</p> <p></p> <p>Go to \"Other Converters\" and select \"DBC to DBF.\" Choose a <code>.dbc</code> input file and click \"Convert.\" Note the \"Output File\" destination.</p> <p></p> <p>Return to the \"CAN\" tab and click \"Database\" \u2192 \"Associate.\" Choose the <code>.dbf</code> file.</p> <p></p> <p>Under \"Message Window\" enable \"Interpret.\"</p> <p>Note</p> <p>\"Interpret\" is disabled until a database is associated.</p> <p></p> <p>Now look at the Message Window. Each message should have a name (ex. <code>FC_Status</code>) and you can expand the signals by clicking the +.</p> <p></p> DBC file corresponding to this screenshot <pre><code>BO_ 255 FC_Status: 5 FC\n    SG_ GovStatus : 0|8@1+ (1,0) [0|255] \"\" LVC, PC_SG\n    SG_ DiStatus : 8|8@1+ (1,0) [0|255] \"\" LVC, PC_SG\n    SG_ MiStatus : 16|8@1+ (1,0) [0|255] \"\" LVC, PC_SG\n    SG_ BmStatus : 24|8@1+ (1,0) [0|255] \"\" LVC, PC_SG\n    SG_ UserFlag : 32|8@1+ (1,0) [0|255] \"\" LVC, PC_SG\n\nBO_ 111 LvControllerStatus: 6 LVC\n    SG_ LvState : 0|8@1+ (1,0) [0|1] \"\"  RPI\n    SG_ Elapsed : 8|32@1- (1,0) [0|1] \"\"  RPI\n    SG_ Flag : 40|1@1+ (1,0) [0|1] \"\"  RPI\n\nBO_ 113 SuspensionTravel34: 2 LVC\n    SG_ STP3 : 0|8@1+ (1,0) [0|255] \"\" FC,RPI\n    SG_ STP4 : 8|8@1+ (1,0) [0|255] \"\" FC,RPI\n\nBO_ 257 DashStatus: 1 Dash\n    SG_ Status : 0|8@1+ (1,0) [0|255] \"\" FC\n</code></pre> <p>For example:</p> <ul> <li>In the DBC, <code>FC_Status</code> has ID 255 which is hex <code>0x0FF</code> in Busmaster.</li> <li>The <code>Elapsed</code> field is is bits 8-39 of the <code>LvControllerStatus</code> message. The \"Data Bytes\" are <code>0x00001F95</code> which is hex for 8085, matching the interpreted value.</li> </ul>"},{"location":"tutorials/busmaster/#send-can-messages","title":"Send CAN Messages","text":"<p>Open the \"Transmit Window.\"</p> <p></p> <p>Select \"Add Message\" and choose a message from the database to send.</p> <p>Warning</p> <p>If you are using multiple CAN channels, you must configure the \"Channel\" column to send the message on the right one.</p> <p>Edit the \"Signal Details\" to change the signal values.</p> <p>Click \"Send Message\" to send it once, or enable \"Repetition\" to periodically send the message.</p> <p></p>"},{"location":"tutorials/busmaster/#troubleshooting","title":"Troubleshooting","text":"Can't transmit over Channel 2 <p>There is a bug in the Transmit Window. If you change the transmit Channel to 2, you will lose the message's database information like its name and signals.</p> <p>You can still send a message over channel 2 but must manually set the bits in the \"Data Byte View.\"</p> <p>If you only need to transmit over one channel, connect the Ch.1 D-Sub to that bus to avoid this error.</p> <p>Channel 1: Message has name and signal breakdown</p> <p></p> <p>Channel 2: Message doesn't have name or signals</p> <p></p>"},{"location":"tutorials/orion-bms/","title":"Orion BMS","text":""},{"location":"tutorials/orion-bms/#orion-bms","title":"Orion BMS","text":"<p>We use the Orion BMS 2. The Battery Management System is a device in our car which monitors the state of the accumulator (HV battery). It measures voltage, current, and SoC and uses this information to safely manage the discharge rate and battery health.</p> <p>Follow this guide to set up the Orion BMS for debugging.</p>"},{"location":"tutorials/orion-bms/#software-requirements","title":"Software Requirements","text":""},{"location":"tutorials/orion-bms/#orion-bms-2-utility","title":"Orion BMS 2 Utility","text":"<ol> <li>Go to the BMS product page https://www.orionbms.com/products/orion-bms-standard/.</li> <li> <p>Under Software Downloads, select the appropriate installer.</p> <p></p> </li> <li> <p>Run the installer. Use the default settings.</p> Error: Windows Protected your PC <p>If you encounter this error, select More Info then Run Anyway.</p> <p></p> </li> <li> <p>Run the Orion BMS Utility. Install the Java Runtime Environment if prompted.</p> </li> </ol>"},{"location":"tutorials/orion-bms/#candapter","title":"CANdapter","text":"<ol> <li>Go to the BMS product page https://www.orionbms.com/products/orion-bms-standard/.</li> <li> <p>Under Software Downloads, follow the CANdapter Link.</p> <p></p> </li> <li> <p>Click on the Utilities menu.</p> <p></p> </li> <li> <p>Download the setup utility and install. Use the default settings.</p> </li> </ol>"},{"location":"tutorials/orion-bms/#communicating","title":"Communicating","text":"<ol> <li>\"Connect to BMS\"</li> <li>\"500 baudrate\"</li> <li>\"Download config\"</li> <li>\"Yes, continue\"</li> </ol> <p>This article could use more detail</p>"},{"location":"tutorials/ssh-signing/","title":"SSH and Commit Signing","text":""},{"location":"tutorials/ssh-signing/#ssh-and-commit-signing","title":"SSH and Commit Signing","text":"<p>This tutorial will guide you through setting up an SSH key and commit signing for GitHub. SSH keys are a more secure way to connect to GitHub, rather than other protocols like HTTPS. Commit signing is used to verify that commits are coming from you and have not been tampered with.</p> <p>Warning</p> <p>You must have a verified email address on GitHub to add SSH keys and sign commits.</p>"},{"location":"tutorials/ssh-signing/#create-an-ssh-key","title":"Create an SSH Key","text":"<p>In a bash terminal, enter the following command:</p> WindowsLinux/Mac <pre><code>ssh-keygen -t ed25519 -C \"your_github_email@example.com\"\n</code></pre> <p>When prompted, save to the default location <code>c:/Users/YOU/.ssh/id_ed25519</code> and do not enter a passphrase. This will allow you to use the key without entering a password every time you push to GitHub.</p> <p>Continue with the following commands:</p> <pre><code>cat c:/Users/YOU/.ssh/id_ed25519 | clip\neval \"$(ssh-agent -s)\"\nssh-add c:/Users/YOU/.ssh/id_ed25519\n</code></pre> <pre><code>ssh-keygen -t ed25519 -C \"your_github_email@example.com\"\n</code></pre> <p>When prompted, save to the default location <code>~/.ssh/id_ed25519</code> and do not enter a passphrase. This will allow you to use the key without entering a password every time you push to GitHub.</p> <p>Continue with the following commands:</p> <pre><code>pbcopy &lt; ~/.ssh/id_ed25519.pub\neval \"$(ssh-agent -s)\"\nssh-add ~/.ssh/id_ed25519\n</code></pre> <p>To add the key to your GitHub account, go to https://github.com/settings/ssh/new.</p> <ul> <li>Name your key something descriptive.</li> <li>Select \"Authentication Key\" as the key type.</li> <li>Paste the contents of <code>id_ed25519.pub</code> into the \"Key\" box.</li> <li>Click \"Add SSH Key\".</li> </ul> <p>Open another terminal to test your connection to GitHub by entering the following command:</p> <pre><code>ssh -T git@github.com\n</code></pre> <p>Type \"yes\" when it asks if you want to continue connecting. You should see a message like \"Hi username! You've successfully authenticated, but GitHub does not provide shell access.\"</p>"},{"location":"tutorials/ssh-signing/#enable-commit-signing","title":"Enable Commit Signing","text":"<p>To add a signing key to your GitHub account, go to https://github.com/settings/ssh/new.</p> <ul> <li>Name your key something descriptive.</li> <li>Select \"Signing Key\" as the key type.</li> <li>Paste the contents of <code>id_ed25519.pub</code> into the \"Key\" box.</li> <li>Click \"Add SSH Key.\"</li> </ul> <p>Update your git configuration in your terminal to automatically sign commits with your key:</p> WindowsLinux/Mac <pre><code>git config --global user.signingkey c:/Users/YOU/.ssh/id_ed25519\ngit config --global gpg.format ssh\ngit config --global commit.gpgsign true\n</code></pre> <pre><code>git config --global user.signingkey ~/.ssh/id_ed25519\ngit config --global gpg.format ssh\ngit config --global commit.gpgsign true\n</code></pre>"},{"location":"tutorials/ssh-signing/#enable-vigilant-mode","title":"Enable Vigilant Mode","text":"<p>Go to https://github.com/settings/ssh and scroll down to the \"Vigilant Mode\" section. Enable \"Enable Vigilant Mode\".</p> <p></p> <p>This will now mark and display all of your commits with a signature verification status tag.</p> <p></p> <p>Verify your commits are signed by checking your commit history on GitHub for \"Verified\" tags.</p>"},{"location":"tutorials/ssh-signing/#set-repo-to-use-ssh","title":"Set Repo to Use SSH","text":"<p>It is likely your repository is using HTTPS to connect to GitHub. To check which remote URL is currently being used, run the following terminal command inside of a repository:</p> <pre><code>git remote -v\n</code></pre> <p>To convert to SSH, run the following command, replacing <code>orgname</code> and <code>reponame</code> with your GitHub organization and repository names (i.e. <code>macformula</code> and <code>racecar</code>):</p> <pre><code>git remote set-url origin git@github.com:orgname/reponame.git\n</code></pre> <p>To avoid this manual configuration in the future, clone repositories using their SSH URL instead of HTTPS.</p> <p></p>"},{"location":"tutorials/ssh-signing/#resources","title":"Resources","text":"<ul> <li> <p>Generating a new SSH key</p> </li> <li> <p>Testing your SSH connection</p> </li> <li> <p>Managing commit signature verification</p> </li> </ul>"},{"location":"tutorials/wsl-can/","title":"Virtual CAN on WSL2","text":""},{"location":"tutorials/wsl-can/#virtual-can-on-wsl2","title":"Virtual CAN on WSL2","text":"<p>By default, WSL2 does not support Virtual CAN, however it can be enabled by building a custom WSL2 kernel.</p> <p>This setup assumes you are running within WSL. If you do not have WSL installed, open up a Windows terminal and run:</p> <pre><code>wsl --install\n</code></pre>"},{"location":"tutorials/wsl-can/#step-1-update-the-wsl-environment","title":"Step 1: Update the WSL Environment","text":"<p>Run the following commands in your WSL terminal to update your environment and install the required dependencies.</p> <pre><code>sudo apt-get update -y\n</code></pre>"},{"location":"tutorials/wsl-can/#install-dependencies","title":"Install dependencies","text":"<pre><code>sudo apt install -y dwarves libelf-dev flex bison libssl-dev libncurses-dev bc build-essential make\nsudo apt install -y --no-install-recommends wslu\n</code></pre>"},{"location":"tutorials/wsl-can/#step-2-download-the-wsl2-linux-kernel","title":"Step 2: Download the WSL2 Linux Kernel","text":"<p>To ensure compatibility, you need the specific kernel version of WSL2.</p> <ol> <li> <p>Check your kernel version:</p> <pre><code>uname -r\n</code></pre> <ul> <li>Example output: <code>5.15.153.1-microsoft-standard-WSL2</code></li> <li>Note the version number, as it must match with <code>&lt;your-kernel-version&gt;</code> in step 2, 3, and 4.</li> </ul> </li> <li> <p>Download the kernel source:</p> <ul> <li>Go to the WSL2 Linux Kernel repository.</li> <li>Find and copy the link for the <code>Source code (tar.gz)</code> file matching your kernel version.</li> </ul> </li> <li> <p>Download and extract the file:</p> <pre><code>wget https://github.com/microsoft/WSL2-Linux-Kernel/archive/refs/tags/linux-msft-wsl-&lt;your-kernel-version&gt;.tar.gz\ntar -xf linux-msft-wsl-&lt;your-kernel-version&gt;.tar.gz\n</code></pre> </li> <li> <p>Navigate to the extracted folder:</p> <pre><code>cd WSL2-Linux-Kernel-&lt;your-kernel-version&gt;\n</code></pre> </li> </ol>"},{"location":"tutorials/wsl-can/#step-3-configure-kernel-settings","title":"Step 3: Configure Kernel Settings","text":"<ol> <li> <p>Load current configuration:</p> <pre><code>cat /proc/config.gz | gunzip &gt; .config\n</code></pre> </li> <li> <p>Prepare the kernel for modules:</p> <pre><code>make prepare modules_prepare -j $(expr $(nproc) - 1)\n</code></pre> </li> <li> <p>Open the configuration menu:</p> <pre><code>make menuconfig -j $(expr $(nproc) - 1)\n</code></pre> <p>A menu interface should open. Use this to enable the necessary drivers for Virtual CAN.</p> </li> </ol> <p></p>"},{"location":"tutorials/wsl-can/#enable-can-drivers","title":"Enable CAN Drivers","text":"<ul> <li>Navigate to Networking Support and press <code>Enter</code>.</li> <li>Select CAN BUS subsystem support by pressing <code>M</code>, then press <code>Enter</code>.</li> </ul>"},{"location":"tutorials/wsl-can/#enable-can-device-drivers","title":"Enable CAN Device Drivers","text":"<ul> <li>Navigate to CAN Device Drivers.</li> <li>For each driver shown in the screenshot, press <code>M</code> to enable as a module.</li> <li>Save and exit the configuration menu.</li> </ul>"},{"location":"tutorials/wsl-can/#step-4-compile-and-install-kernel-modules","title":"Step 4: Compile and Install Kernel Modules","text":"<p>Run the following commands to compile and install the Virtual CAN modules:</p> <pre><code>make modules -j $(expr $(nproc) - 1)\nsudo make modules_install\n</code></pre> <p>Then, compile the kernel:</p> <pre><code>make -j $(expr $(nproc) - 1)\n</code></pre>"},{"location":"tutorials/wsl-can/#step-5-configure-wsl-to-use-the-custom-kernel","title":"Step 5: Configure WSL to Use the Custom Kernel","text":"<ol> <li> <p>Create a symbolic link for the module directory, matching your kernel version:</p> <pre><code>sudo ln -s /lib/modules/5.15.153.1-microsoft-standard-WSL2+ /lib/modules/5.15.153.1-microsoft-standard-WSL2\n</code></pre> </li> <li> <p>Copy the vmlinux file:</p> <p>Replace <code>&lt;yourwindowsloginname&gt;</code> with your actual Windows username:</p> <pre><code>cp vmlinux /mnt/c/Users/&lt;yourwindowsloginname&gt;/\n</code></pre> <ul> <li>In Windows File Explorer, you should now see a file named <code>vmlinux</code>.</li> </ul> </li> <li> <p>Configure <code>.wslconfig</code>:</p> <p>Create a file named <code>.wslconfig</code> in the same directory (i.e. in <code>/mnt/c/Users/&lt;yourwindowsloginname&gt;/</code>) and paste the following to the file:</p> <pre><code>[wsl2]\nkernel=C:\\\\Users\\\\&lt;yourwindowsloginname&gt;\\\\vmlinux\n</code></pre> </li> </ol>"},{"location":"tutorials/wsl-can/#step-6-restart-wsl-and-verify","title":"Step 6: Restart WSL and Verify","text":"<ol> <li> <p>In a separate Windows terminal (not WSL), restart WSL:</p> <pre><code>wsl --shutdown\n</code></pre> </li> <li> <p>Wait ~10 seconds, then check that WSL has no active processes:</p> <pre><code>wsl --list -v\n</code></pre> </li> <li> <p>Verify the setup by running WSL again, then execute these commands:</p> <pre><code>sudo modprobe can\nsudo modprobe can-raw\nsudo modprobe vcan\n</code></pre> </li> </ol> <p>If there is no other message, the installation was successful.</p>"}]}